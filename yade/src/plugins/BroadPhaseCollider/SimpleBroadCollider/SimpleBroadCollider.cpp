#include "SimpleBroadCollider.hpp"
#include "BVOverlapper.hpp"
#include "Body.hpp"

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

SimpleBroadCollider::SimpleBroadCollider () : BroadPhaseCollider()
{
	nbPotentialCollisions = 0;
	overlapper = shared_ptr<Overlapper>(new BVOverlapper());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

SimpleBroadCollider::~SimpleBroadCollider ()
{

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void SimpleBroadCollider::processAttributes()
{

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void SimpleBroadCollider::registerAttributes()
{
}


///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

int SimpleBroadCollider::broadPhaseCollisionTest(const std::vector<shared_ptr<Body> >& bodies,std::list<shared_ptr<Contact> >& contacts)
{	
	nbPotentialCollisions=0;
	
	/*std::list<shared_ptr<Contact> >::iterator ci = contacts.begin();
	std::list<shared_ptr<Contact> >::iterator ciEnd = contacts.end();
	for(;ci!=ciEnd;++ci)
	{
		delete (*ci)->contactModel;
		delete (*ci);
	}*/
	contacts.clear();
	
	for(unsigned int i=0;i<bodies.size()-1 ; i++)
	{
		shared_ptr<BoundingVolume> bv1 = bodies[i]->bv;
		for(unsigned int j=i+1;j<bodies.size() ; j++)
		{	
			shared_ptr<BoundingVolume> bv2 = bodies[j]->bv;
			if ( !(bodies[i]->isDynamic==false && bodies[j]->isDynamic==false) && overlapper->overlapp(bv1,bv2))
			{
				contacts.push_back(shared_ptr<Contact>(new Contact(i,j)));
				nbPotentialCollisions++;
			}
		}
	}
	  
	return nbPotentialCollisions;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
