/***************************************************************************
 *   Copyright (C) 2004 by Olivier Galizzi                                 *
 *   olivier.galizzi@imag.fr                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

#include <math.h>

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Constants.hpp"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2::Vector2 () : Serializable()
{
    // For efficiency in construction of large arrays of vectors, the
    // default constructor does not initialize the vector.
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2::Vector2 (float fX, float fY)  : Serializable()
{
    x = fX;
    y = fY;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2::Vector2 (float afCoordinate[2]) : Serializable()
{
    x = afCoordinate[0];
    y = afCoordinate[1];
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2::Vector2 (const Vector2& rkVector) : Serializable()
{
    x = rkVector.x;
    y = rkVector.y;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2& Vector2::operator= (const Vector2& rkVector)
{
    x = rkVector.x;
    y = rkVector.y;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool Vector2::operator== (const Vector2& rkVector) const
{
    if ( FUZZ == 0.0f )
    {
        return x == rkVector.x && y == rkVector.y;
    }
    else
    {
        return fabs(x - rkVector.x) <= FUZZ
            && fabs(y - rkVector.y) <= FUZZ;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool Vector2::operator!= (const Vector2& rkVector) const
{
    if ( FUZZ == 0.0f )
    {
        return x != rkVector.x || y != rkVector.y;
    }
    else
    {
        return fabs(x - rkVector.x) > FUZZ
            || fabs(y - rkVector.y) > FUZZ;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline float& Vector2::operator[] (int i) const
{
    return ((float*)this)[i];
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2::operator float* ()
{
    return (float*)this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 Vector2::operator+ (const Vector2& rkVector) const
{
    return Vector2(x+rkVector.x,y+rkVector.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 Vector2::operator- (const Vector2& rkVector) const
{
    return Vector2(x-rkVector.x,y-rkVector.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 Vector2::operator* (float fScalar) const
{
    return Vector2(fScalar*x,fScalar*y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 Vector2::operator/ (float fScalar) const
{
    Vector2 kQuot;

    if ( fScalar != 0.0f )
    {
        float fInvScalar = 1.0f/fScalar;
        kQuot.x = fInvScalar*x;
        kQuot.y = fInvScalar*y;
        return kQuot;
    }
    else
    {
        return Vector2(Constants::MAX_FLOAT,Constants::MAX_FLOAT);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 Vector2::operator- () const
{
    return Vector2(-x,-y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2 operator* (float fScalar, const Vector2& rkVector)
{
  return Vector2(fScalar*rkVector.x,fScalar*rkVector.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2& Vector2::operator+= (const Vector2& rkVector)
{
    x += rkVector.x;
    y += rkVector.y;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2& Vector2::operator-= (const Vector2& rkVector)
{
    x -= rkVector.x;
    y -= rkVector.y;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2& Vector2::operator*= (float fScalar)
{
    x *= fScalar;
    y *= fScalar;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline Vector2& Vector2::operator/= (float fScalar)
{
    if ( fScalar != 0.0f )
    {
        float fInvScalar = 1.0f/fScalar;
        x *= fInvScalar;
        y *= fInvScalar;
    }
    else
    {
        x = Constants::MAX_FLOAT;
        y = Constants::MAX_FLOAT;
    }

    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline float Vector2::squaredLength () const
{
    return x*x + y*y;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline float Vector2::length () const
{
    return sqrt(x*x + y*y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

inline float Vector2::dot (const Vector2& rkVector) const
{
    return x*rkVector.x + y*rkVector.y;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
