# The purpose of this file is twofold: 
# 1. it tells python that woo (this directory) is package of python modules
#	see http://http://www.python.org/doc/2.1.3/tut/node8.html#SECTION008400000000000000000
#
# 2. import the runtime namespace (will be populated from within c++)
#

"""Common initialization core for woo.

This file is executed when anything is imported from woo for the first time.
It loads woo plugins and injects c++ class constructors to the __builtins__
(that might change in the future, though) namespace, making them available
everywhere.
"""


#
# import options
#
import wooOptions
import woo.runtime
# detect if $DISPLAY is usable unless forbidden
if not wooOptions.forceNoGui:
	import Xlib.display
	# PyQt4's QApplication does exit(1) if it is unable to connect to the display
	# we however want to handle this gracefully, therefore
	# we test the connection with bare xlib first, which merely raises DisplayError
	try:
		# contrary to display.Display, _BaseDisplay does not check for extensions and that avoids spurious message "Xlib.protocol.request.QueryExtension" (bug?)
		Xlib.display._BaseDisplay();
		woo.runtime.hasDisplay=True
	except: 
		# usually Xlib.error.DisplayError, but there can be Xlib.error.XauthError etc as well
		# let's just pretend any exception means the display would not work
		pass

# API compatibility for PySide vs. PyQt
# must be called before PyQt4 is ever imported
# don't do that if someone imported PyQt4/PySide already
# it would lead to crash
import sys
if woo.runtime.hasDisplay and ('PyQt4' not in sys.modules) and ('PySide' not in sys.modules):
	if woo.runtime.ipython_version>=11:
		import IPython.external.qt
		IPython.external.qt.prepare_pyqt4()

if 1:
	import ctypes,sys
	try:
		import dl
	except ImportError:
		import DLFCN as dl
	if False: # not eval('${mono}'):
		# see file:///usr/share/doc/python2.6/html/library/sys.html#sys.setdlopenflags
		# and various web posts on the topic, e.g.
		# * http://gcc.gnu.org/faq.html#dso
		# * http://www.code-muse.com/blog/?p=58
		# * http://wiki.python.org/moin/boost.python/CrossExtensionModuleDependencies
		sys.setdlopenflags(dl.RTLD_NOW | dl.RTLD_GLOBAL)
	else: sys.setdlopenflags(dl.RTLD_NOW)

	# important: initialize c++ by importing libstdc++ directly
	# see http://www.abclinuxu.cz/poradna/programovani/show/286322
	# https://bugs.launchpad.net/bugs/490744
	libstdcxx='${libstdcxx}' # substituted by scons
	ctypes.cdll.LoadLibrary(libstdcxx)
	#
	# now ready for c++ imports

# find plugin directory
import os,os.path
from . import config

# enable warnings which are normally invisible, such as DeprecationWarning
import warnings
warnings.simplefilter('default')

try: # backwards-compat for miniEigen (new is minieigen)
	import miniEigen
	sys.modules['minieigen']=miniEigen
	warnings.warn("'miniEigen' was imported and aliased to the new name 'minieigen' (update your installation to use 'minieigen' only).")
except ImportError: pass

# import eigen before plugins because of its converters, so that default args to python methods can use Vector3r etc
import minieigen

# c++ initialization code
from . import _cxxInternal
_cxxInternal.initialize(config.confDir)
cxxInternalFile=_cxxInternal.__file__

from . import core
master=core.Master.instance
#
# create compiled python modules
#
if 0:
	import imp
	for mod in master.compiledPyModules:
		print 'Loading compiled module',mod,'from',plugins[0]
		# this inserts the module to sys.modules automatically
		imp.load_dynamic(mod,cxxInternalFile)
# WORKAROUND: create temporary symlinks
# this is UGLY and will probably not work on Windows!!
else:
	allSubmodules=[]
	compiledModDir=woo.master.tmpFilename() # this will be a directory
	import os
	os.mkdir(compiledModDir)
	sys.path.append(compiledModDir)
	# move _customConverters to the start, so that imports reyling on respective converters don't fail
	# remove woo._cxxInternal since it is imported already
	cpm=master.compiledPyModules
	cc='woo._customConverters'
	assert cc in cpm
	## HACK: import _gts this way until it gets separated
	cpm=[cc]+[m for m in cpm if m!=cc and m!='woo._cxxInternal']+['_gts']
	# run imports now
	for mod in cpm:
		modpath=mod.split('.') 
		linkName=os.path.join(compiledModDir,modpath[-1])+'.so' # use just the last part to avoid hierarchy
		os.symlink(os.path.abspath(cxxInternalFile),linkName)
		if 'WOO_DEBUG' in os.environ: print 'Loading compiled module',mod,'from symlink',linkName
		sys.modules[mod]=__import__(modpath[-1])
		#__allSubmodules.append(modpath[1])
		if len(modpath)==1: pass # nothing to do, adding to sys.modules is enough
		elif len(modpath)==2: # subdmodule must be added to module
			globals()[modpath[1]]=sys.modules[mod]
			allSubmodules.append(modpath[1])
		elif len(modpath)==3: # must be added to module and submodule
			allSubmodules.append(modpath[1])
			setattr(__import__('.'.join(modpath[:2])),modpath[2],sys.modules[mod])
		else:
			raise RuntimeError('Module %s does not have 2 or 3 path items and will not be imported properly.'%mod)
	## HACK: gts in-tree
	#import woo.gts
	#sys.modules['gts']=woo.gts

			
		

import _customConverters

from . import system
# create proxies for deprecated classes
deprecatedTypes=system.cxxCtorsDict()
# insert those in the module namespace
globals().update(deprecatedTypes)
# declare what should be imported for "from woo import *"
__all__=deprecatedTypes.keys()+['master']+allSubmodules

# avoids backtrace if crash at finalization (log4cxx)
system.setExitHandlers() 


# fake miniEigen being in woo itself
from minieigen import *

import _monkey # adds methods to c++ classes
import _units 
unit=_units.makeUnitsDict()

# out-of-class docstrings for some classes
try: import _extraDocs
except AttributeError:
	print 'WARN: Error importing py/_extraDocs.py'
	import traceback
	traceback.print_exc()
# attribute aliases
try: import _aliases
except AttributeError:
	print 'WARN: Error importing py/_aliases.py'
	import traceback
	traceback.print_exc()


## DON'T DO THIS:
# import a few "important" modules along with *
#import utils # some others?
# __all__+=[]+dir(minieigen)+dir(wrapper)

