// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__convenience.pypp.hpp"

#include "__call_policies.pypp.hpp"

#include "miniWm3Wrap-toExpose.hpp"

#include "miniWm3Wrap-funcs.ipp"

namespace bp = boost::python;

static boost::python::tuple ToAxisAngle_0ab7c6483b74dde2c1f8a9e7e124e074( Matrix3< double > const & inst ){
    Vector3<double> rkAxis2;
    double rfAngle2;
    inst.ToAxisAngle(rkAxis2, rfAngle2);
    return bp::make_tuple( rkAxis2, rfAngle2 );
}

static boost::python::tuple ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9( Quaternion< double > const & inst ){
    Vector3<double> rkAxis2;
    double rfAngle2;
    inst.ToAxisAngle(rkAxis2, rfAngle2);
    return bp::make_tuple( rkAxis2, rfAngle2 );
}

BOOST_PYTHON_MODULE(miniWm3Wrap){
    { //Matrix3< double >
        typedef bp::class_< Matrix3< double > > Matrix3_exposer_t;
        Matrix3_exposer_t Matrix3_exposer = Matrix3_exposer_t( "Matrix3", bp::init< bp::optional< bool > >(( bp::arg("bZero")=(bool)(true) )) );
        bp::scope Matrix3_scope( Matrix3_exposer );

        Matrix3_exposer.def( bp::init< Matrix3< double > const & >(( bp::arg("rkM") )) );
        Matrix3_exposer.def( bp::init< double, double, double, double, double, double, double, double, double >(( bp::arg("fM00"), bp::arg("fM01"), bp::arg("fM02"), bp::arg("fM10"), bp::arg("fM11"), bp::arg("fM12"), bp::arg("fM20"), bp::arg("fM21"), bp::arg("fM22") )) );

        Matrix3_exposer.def( bp::init< Vector3< double > const &, Vector3< double > const &, Vector3< double > const &, bool >(( bp::arg("rkU"), bp::arg("rkV"), bp::arg("rkW"), bp::arg("bColumns") )) );
        Matrix3_exposer.def( bp::init< Vector3< double > const *, bool >(( bp::arg("akV"), bp::arg("bColumns") )) );
        Matrix3_exposer.def( bp::init< double, double, double >(( bp::arg("fM00"), bp::arg("fM11"), bp::arg("fM22") )) );
        Matrix3_exposer.def( bp::init< Vector3< double > const &, double >(( bp::arg("rkAxis"), bp::arg("fAngle") )) );
        Matrix3_exposer.def( bp::init< Vector3< double > const &, Vector3< double > const & >(( bp::arg("rkU"), bp::arg("rkV") )) );
        { //Matrix3< double >::Determinant
        
            typedef Matrix3< double > exported_class_t;
            typedef double ( exported_class_t::*Determinant_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Determinant"
                , Determinant_function_type( &Matrix3< double >::Determinant ) );
        
        }
        { //Matrix3< double >::EigenDecomposition
        
            typedef Matrix3< double > exported_class_t;
            typedef void ( exported_class_t::*EigenDecomposition_function_type )( Matrix3< double > &,Matrix3< double > & ) const;
            
            Matrix3_exposer.def( 
                "EigenDecomposition"
                , EigenDecomposition_function_type( &Matrix3< double >::EigenDecomposition )
                , ( bp::arg("rkRot"), bp::arg("rkDiag") ) );
        
        }
        { //Matrix3< double >::FromAxisAngle
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > & ( exported_class_t::*FromAxisAngle_function_type )( Vector3< double > const &,double ) ;
            
            Matrix3_exposer.def( 
                "FromAxisAngle"
                , FromAxisAngle_function_type( &Matrix3< double >::FromAxisAngle )
                , ( bp::arg("rkAxis"), bp::arg("fAngle") )
                , bp::return_self< >() );
        
        }
        { //Matrix3< double >::GetColumn
        
            typedef Matrix3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*GetColumn_function_type )( int ) const;
            
            Matrix3_exposer.def( 
                "GetColumn"
                , GetColumn_function_type( &Matrix3< double >::GetColumn )
                , ( bp::arg("iCol") ) );
        
        }
        { //Matrix3< double >::GetRow
        
            typedef Matrix3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*GetRow_function_type )( int ) const;
            
            Matrix3_exposer.def( 
                "GetRow"
                , GetRow_function_type( &Matrix3< double >::GetRow )
                , ( bp::arg("iRow") ) );
        
        }
        { //Matrix3< double >::Inverse
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Inverse"
                , Inverse_function_type( &Matrix3< double >::Inverse ) );
        
        }
        { //Matrix3< double >::SetColumn
        
            typedef Matrix3< double > exported_class_t;
            typedef void ( exported_class_t::*SetColumn_function_type )( int,Vector3< double > const & ) ;
            
            Matrix3_exposer.def( 
                "SetColumn"
                , SetColumn_function_type( &Matrix3< double >::SetColumn )
                , ( bp::arg("iCol"), bp::arg("rkV") ) );
        
        }
        { //Matrix3< double >::SetRow
        
            typedef Matrix3< double > exported_class_t;
            typedef void ( exported_class_t::*SetRow_function_type )( int,Vector3< double > const & ) ;
            
            Matrix3_exposer.def( 
                "SetRow"
                , SetRow_function_type( &Matrix3< double >::SetRow )
                , ( bp::arg("iRow"), bp::arg("rkV") ) );
        
        }
        { //Matrix3< double >::ToAxisAngle
        
            typedef Matrix3< double > exported_class_t;
            typedef boost::python::tuple ( *ToAxisAngle_function_type )( Matrix3<double> const & );
            
            Matrix3_exposer.def( 
                "ToAxisAngle"
                , ToAxisAngle_function_type( &ToAxisAngle_0ab7c6483b74dde2c1f8a9e7e124e074 )
                , ( bp::arg("inst") ) );
        
        }
        { //Matrix3< double >::Transpose
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Transpose_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Transpose"
                , Transpose_function_type( &Matrix3< double >::Transpose ) );
        
        }
        Matrix3_exposer.def( bp::self != bp::self );
        { //Matrix3< double >::operator()
        
            typedef Matrix3< double > exported_class_t;
            typedef double ( exported_class_t::*__call___function_type )( int,int ) const;
            
            Matrix3_exposer.def( 
                "__call__"
                , __call___function_type( &Matrix3< double >::operator() )
                , ( bp::arg("iRow"), bp::arg("iCol") ) );
        
        }
        Matrix3_exposer.def( bp::self * bp::self );
        Matrix3_exposer.def( bp::self * bp::other< double >() );
        Matrix3_exposer.def( bp::self * bp::other< Vector3< double > >() );
        Matrix3_exposer.def( bp::self *= bp::other< double >() );
        Matrix3_exposer.def( bp::self + bp::self );
        Matrix3_exposer.def( bp::self += bp::self );
        Matrix3_exposer.def( bp::self - bp::self );
        Matrix3_exposer.def( -bp::self );
        Matrix3_exposer.def( bp::self -= bp::self );
        Matrix3_exposer.def( bp::self / bp::other< double >() );
        Matrix3_exposer.def( bp::self /= bp::other< double >() );
        Matrix3_exposer.def( bp::self < bp::self );
        Matrix3_exposer.def( bp::self <= bp::self );
        { //Matrix3< double >::operator=
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > & ( exported_class_t::*assign_function_type )( Matrix3< double > const & ) ;
            
            Matrix3_exposer.def( 
                "assign"
                , assign_function_type( &Matrix3< double >::operator= )
                , ( bp::arg("rkM") )
                , bp::return_self< >() );
        
        }
        Matrix3_exposer.def( bp::self == bp::self );
        Matrix3_exposer.def( bp::self > bp::self );
        Matrix3_exposer.def( bp::self >= bp::self );
        Matrix3_exposer.def_readonly( "IDENTITY", Matrix3< double >::IDENTITY );
        Matrix3_exposer.def_readonly( "ZERO", Matrix3< double >::ZERO );
        Matrix3_exposer.def( bp::other< Real >() * bp::self );
        Matrix3_exposer.def("__len__",&::Matrix3_len).staticmethod("__len__")   .def("__setitem__",&::Matrix3_set_item)   .def("__getitem__",&::Matrix3_get_item)   .def("__str__",&::Matrix3_str)   .def("__repr__",&::Matrix3_str)  /* extras for matrices */ .def("__setitem__",&::Matrix3_set_item_linear).def("__getitem__",&::Matrix3_get_item_linear);
    }

    { //Quaternion< double >
        typedef bp::class_< Quaternion< double > > Quaternion_exposer_t;
        Quaternion_exposer_t Quaternion_exposer = Quaternion_exposer_t( "Quaternion", bp::init< >() );
        bp::scope Quaternion_scope( Quaternion_exposer );
        Quaternion_exposer.def( bp::init< double, double, double, double >(( bp::arg("fW"), bp::arg("fX"), bp::arg("fY"), bp::arg("fZ") )) );
        Quaternion_exposer.def( bp::init< Quaternion< double > const & >(( bp::arg("rkQ") )) );
        Quaternion_exposer.def( bp::init< Matrix3< double > const & >(( bp::arg("rkRot") )) );

        Quaternion_exposer.def( bp::init< Vector3< double > const &, double >(( bp::arg("rkAxis"), bp::arg("fAngle") )) );
        Quaternion_exposer.def( bp::init< Vector3< double > const * >(( bp::arg("akRotColumn") )) );

        { //Quaternion< double >::Align
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*Align_function_type )( Vector3< double > const &,Vector3< double > const & ) ;
            
            Quaternion_exposer.def( 
                "Align"
                , Align_function_type( &Quaternion< double >::Align )
                , ( bp::arg("rkV1"), bp::arg("rkV2") )
                , bp::return_self< >() );
        
        }
        { //Quaternion< double >::Conjugate
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Conjugate_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Conjugate"
                , Conjugate_function_type( &Quaternion< double >::Conjugate ) );
        
        }
        { //Quaternion< double >::Dot
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Quaternion< double > const & ) const;
            
            Quaternion_exposer.def( 
                "Dot"
                , Dot_function_type( &Quaternion< double >::Dot )
                , ( bp::arg("rkQ") ) );
        
        }
        { //Quaternion< double >::FromAxisAngle
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*FromAxisAngle_function_type )( Vector3< double > const &,double ) ;
            
            Quaternion_exposer.def( 
                "FromAxisAngle"
                , FromAxisAngle_function_type( &Quaternion< double >::FromAxisAngle )
                , ( bp::arg("rkAxis"), bp::arg("fAngle") )
                , bp::return_self< >() );
        
        }
        { //Quaternion< double >::Inverse
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Inverse"
                , Inverse_function_type( &Quaternion< double >::Inverse ) );
        
        }
        { //Quaternion< double >::Length
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Length"
                , Length_function_type( &Quaternion< double >::Length ) );
        
        }
        { //Quaternion< double >::Normalize
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Quaternion_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Quaternion< double >::Normalize ) );
        
        }
        { //Quaternion< double >::Rotate
        
            typedef Quaternion< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*Rotate_function_type )( Vector3< double > const & ) const;
            
            Quaternion_exposer.def( 
                "Rotate"
                , Rotate_function_type( &Quaternion< double >::Rotate )
                , ( bp::arg("rkVector") ) );
        
        }
        { //Quaternion< double >::SquaredLength
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "SquaredLength"
                , SquaredLength_function_type( &Quaternion< double >::SquaredLength ) );
        
        }
        { //Quaternion< double >::ToAxisAngle
        
            typedef Quaternion< double > exported_class_t;
            typedef boost::python::tuple ( *ToAxisAngle_function_type )( Quaternion<double> const & );
            
            Quaternion_exposer.def( 
                "ToAxisAngle"
                , ToAxisAngle_function_type( &ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9 )
                , ( bp::arg("inst") ) );
        
        }
        { //Quaternion< double >::ToRotationMatrix
        
            typedef Quaternion< double > exported_class_t;
            typedef void ( exported_class_t::*ToRotationMatrix_function_type )( Matrix3< double > & ) const;
            
            Quaternion_exposer.def( 
                "ToRotationMatrix"
                , ToRotationMatrix_function_type( &Quaternion< double >::ToRotationMatrix )
                , ( bp::arg("rkRot") ) );
        
        }
        { //Quaternion< double >::ToRotationMatrix
        
            typedef Quaternion< double > exported_class_t;
            typedef void ( exported_class_t::*ToRotationMatrix_function_type )( Vector3< double > * ) const;
            
            Quaternion_exposer.def( 
                "ToRotationMatrix"
                , ToRotationMatrix_function_type( &Quaternion< double >::ToRotationMatrix )
                , ( bp::arg("akRotColumn") ) );
        
        }
        { //Quaternion< double >::W
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*W_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "W"
                , W_function_type( &Quaternion< double >::W ) );
        
        }
        { //Quaternion< double >::X
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "X"
                , X_function_type( &Quaternion< double >::X ) );
        
        }
        { //Quaternion< double >::Y
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Y"
                , Y_function_type( &Quaternion< double >::Y ) );
        
        }
        { //Quaternion< double >::Z
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Z"
                , Z_function_type( &Quaternion< double >::Z ) );
        
        }
        Quaternion_exposer.def( bp::self != bp::self );
        Quaternion_exposer.def( bp::self * bp::self );
        Quaternion_exposer.def( bp::self * bp::other< double >() );
        Quaternion_exposer.def( bp::self *= bp::other< double >() );
        Quaternion_exposer.def( bp::self + bp::self );
        Quaternion_exposer.def( bp::self += bp::self );
        Quaternion_exposer.def( bp::self - bp::self );
        Quaternion_exposer.def( -bp::self );
        Quaternion_exposer.def( bp::self -= bp::self );
        Quaternion_exposer.def( bp::self / bp::other< double >() );
        Quaternion_exposer.def( bp::self /= bp::other< double >() );
        Quaternion_exposer.def( bp::self < bp::self );
        Quaternion_exposer.def( bp::self <= bp::self );
        { //Quaternion< double >::operator=
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*assign_function_type )( Quaternion< double > const & ) ;
            
            Quaternion_exposer.def( 
                "assign"
                , assign_function_type( &Quaternion< double >::operator= )
                , ( bp::arg("rkQ") )
                , bp::return_self< >() );
        
        }
        Quaternion_exposer.def( bp::self == bp::self );
        Quaternion_exposer.def( bp::self > bp::self );
        Quaternion_exposer.def( bp::self >= bp::self );
        Quaternion_exposer.def_readonly( "IDENTITY", Quaternion< double >::IDENTITY );
        Quaternion_exposer.def_readonly( "ZERO", Quaternion< double >::ZERO );
        Quaternion_exposer.def( bp::self * bp::other< Vector3< double > >() );
        Quaternion_exposer.def( bp::self_ns::str( bp::self ) );
        Quaternion_exposer.def("__len__",&::Quaternion_len).staticmethod("__len__").def("__setitem__",&::Quaternion_set_item).def("__getitem__",&::Quaternion_get_item).def("__str__",&::Quaternion_str).def("__repr__",&::Quaternion_str);
    }

    { //Vector2< double >
        typedef bp::class_< Vector2< double > > Vector2_exposer_t;
        Vector2_exposer_t Vector2_exposer = Vector2_exposer_t( "Vector2", bp::init< >() );
        bp::scope Vector2_scope( Vector2_exposer );
        Vector2_exposer.def( bp::init< double, double >(( bp::arg("fX"), bp::arg("fY") )) );


        Vector2_exposer.def( bp::init< Vector2< double > const & >(( bp::arg("rkV") )) );
        { //Vector2< double >::Dot
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector2< double > const & ) const;
            
            Vector2_exposer.def( 
                "Dot"
                , Dot_function_type( &Vector2< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector2< double >::Length
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "Length"
                , Length_function_type( &Vector2< double >::Length ) );
        
        }
        { //Vector2< double >::Normalize
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector2_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Vector2< double >::Normalize ) );
        
        }
        { //Vector2< double >::SquaredLength
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "SquaredLength"
                , SquaredLength_function_type( &Vector2< double >::SquaredLength ) );
        
        }
        { //Vector2< double >::X
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "X"
                , X_function_type( &Vector2< double >::X ) );
        
        }
        { //Vector2< double >::Y
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "Y"
                , Y_function_type( &Vector2< double >::Y ) );
        
        }
        Vector2_exposer.def( bp::self != bp::self );
        Vector2_exposer.def( bp::self * bp::other< double >() );
        Vector2_exposer.def( bp::self *= bp::other< double >() );
        Vector2_exposer.def( bp::self + bp::self );
        Vector2_exposer.def( bp::self += bp::self );
        Vector2_exposer.def( bp::self - bp::self );
        Vector2_exposer.def( -bp::self );
        Vector2_exposer.def( bp::self -= bp::self );
        Vector2_exposer.def( bp::self / bp::other< double >() );
        Vector2_exposer.def( bp::self /= bp::other< double >() );
        Vector2_exposer.def( bp::self < bp::self );
        Vector2_exposer.def( bp::self <= bp::self );
        { //Vector2< double >::operator=
        
            typedef Vector2< double > exported_class_t;
            typedef Vector2< double > & ( exported_class_t::*assign_function_type )( Vector2< double > const & ) ;
            
            Vector2_exposer.def( 
                "assign"
                , assign_function_type( &Vector2< double >::operator= )
                , ( bp::arg("rkV") )
                , bp::return_self< >() );
        
        }
        Vector2_exposer.def( bp::self == bp::self );
        Vector2_exposer.def( bp::self > bp::self );
        Vector2_exposer.def( bp::self >= bp::self );
        Vector2_exposer.def_readonly( "ONE", Vector2< double >::ONE );
        Vector2_exposer.def_readonly( "UNIT_X", Vector2< double >::UNIT_X );
        Vector2_exposer.def_readonly( "UNIT_Y", Vector2< double >::UNIT_Y );
        Vector2_exposer.def_readonly( "ZERO", Vector2< double >::ZERO );
        Vector2_exposer.def( bp::other< Real >() * bp::self );
        Vector2_exposer.def("__len__",&::Vector2_len)   .staticmethod("__len__").def("__setitem__",&::Vector2_set_item)   .def("__getitem__",&::Vector2_get_item)   .def("__str__",&::Vector2_str)   .def("__repr__",&::Vector2_str);
    }

    { //Vector3< double >
        typedef bp::class_< Vector3< double > > Vector3_exposer_t;
        Vector3_exposer_t Vector3_exposer = Vector3_exposer_t( "Vector3", bp::init< >() );
        bp::scope Vector3_scope( Vector3_exposer );
        Vector3_exposer.def( bp::init< double, double, double >(( bp::arg("fX"), bp::arg("fY"), bp::arg("fZ") )) );


        Vector3_exposer.def( bp::init< Vector3< double > const & >(( bp::arg("rkV") )) );
        { //Vector3< double >::Cross
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*Cross_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "Cross"
                , Cross_function_type( &Vector3< double >::Cross )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Dot
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "Dot"
                , Dot_function_type( &Vector3< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Length
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Length"
                , Length_function_type( &Vector3< double >::Length ) );
        
        }
        { //Vector3< double >::Normalize
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector3_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Vector3< double >::Normalize ) );
        
        }
        { //Vector3< double >::SquaredLength
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "SquaredLength"
                , SquaredLength_function_type( &Vector3< double >::SquaredLength ) );
        
        }
        { //Vector3< double >::UnitCross
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*UnitCross_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "UnitCross"
                , UnitCross_function_type( &Vector3< double >::UnitCross )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::X
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "X"
                , X_function_type( &Vector3< double >::X ) );
        
        }
        { //Vector3< double >::Y
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Y"
                , Y_function_type( &Vector3< double >::Y ) );
        
        }
        { //Vector3< double >::Z
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Z"
                , Z_function_type( &Vector3< double >::Z ) );
        
        }
        Vector3_exposer.def( bp::self != bp::self );
        Vector3_exposer.def( bp::self * bp::other< double >() );
        Vector3_exposer.def( bp::self *= bp::other< double >() );
        Vector3_exposer.def( bp::self + bp::self );
        Vector3_exposer.def( bp::self += bp::self );
        Vector3_exposer.def( bp::self - bp::self );
        Vector3_exposer.def( -bp::self );
        Vector3_exposer.def( bp::self -= bp::self );
        Vector3_exposer.def( bp::self / bp::other< double >() );
        Vector3_exposer.def( bp::self /= bp::other< double >() );
        Vector3_exposer.def( bp::self < bp::self );
        Vector3_exposer.def( bp::self <= bp::self );
        { //Vector3< double >::operator=
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > & ( exported_class_t::*assign_function_type )( Vector3< double > const & ) ;
            
            Vector3_exposer.def( 
                "assign"
                , assign_function_type( &Vector3< double >::operator= )
                , ( bp::arg("rkV") )
                , bp::return_self< >() );
        
        }
        Vector3_exposer.def( bp::self == bp::self );
        Vector3_exposer.def( bp::self > bp::self );
        Vector3_exposer.def( bp::self >= bp::self );
        Vector3_exposer.def_readonly( "ONE", Vector3< double >::ONE );
        Vector3_exposer.def_readonly( "UNIT_X", Vector3< double >::UNIT_X );
        Vector3_exposer.def_readonly( "UNIT_Y", Vector3< double >::UNIT_Y );
        Vector3_exposer.def_readonly( "UNIT_Z", Vector3< double >::UNIT_Z );
        Vector3_exposer.def_readonly( "ZERO", Vector3< double >::ZERO );
        Vector3_exposer.def( bp::self * bp::other< Matrix3< double > >() );
        Vector3_exposer.def( bp::self_ns::str( bp::self ) );
        Vector3_exposer.def("__len__",&::Vector3_len)   .staticmethod("__len__").def("__setitem__",&::Vector3_set_item)   .def("__getitem__",&::Vector3_get_item)   .def("__str__",&::Vector3_str)   .def("__repr__",&::Vector3_str);
    }

    custom_Vector3r_from_tuple();

    bp::scope().attr("NaN") = NaN;
}
