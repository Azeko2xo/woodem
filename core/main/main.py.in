#!${pyExecutable}
# encoding: utf-8
# syntax:python

import sys,os,os.path,time
# get yade path (allow YADE_PREFIX to override)
prefix,suffix='${runtimePREFIX}' if not os.environ.has_key('YADE_PREFIX') else os.environ['YADE_PREFIX'],'${SUFFIX}'
sys.path.append(os.path.join(prefix,'lib','yade'+suffix,'py'))
# duplicate some items from yade.config here, so that we can increase verbosity when the c++ part is booting
debug,features,version=bool(${debug}),'${features}'.split(','),'${realVersion}'

## python2.5 relative module imports workaround
v=sys.version_info
if v[0]==2 and v[1]<=5:
	for submodule in ('yade','gts','yade/tests'):
		sys.path.append(os.path.join(prefix,'lib','yade'+suffix,'py',submodule))

# handle command-line options first
import optparse
par=optparse.OptionParser(usage='%prog [options] [ simulation.xml[.bz2] | script.py [script options]]',prog=os.path.basename(sys.argv[0]),version='%s (%s)%s'%(version,','.join(features),' with debugging symbols' if debug else ''),description="Yade: open-source platform for dynamic compuations. Homepage http://www.yade-dem.org, code hosted at http://www.launchpad.net/yade. This is version %s (with features %s %s)."%(version,','.join(features),', with debugging symbols' if debug else ''))
par.add_option('-j','--threads',help='Number of OpenMP threads to run; defaults to number of cores. Equivalent to setting OMP_NUM_THREADS environment variable.',dest='threads',type='int')
par.add_option('--update',help='Update deprecated class names in given script(s) using text search & replace. Changed files will be backed up with ~ suffix. Exit when done without running any simulation.',dest='updateScripts',action='store_true')
par.add_option('--nice',help='Increase nice level (i.e. decrease priority) by given number.',dest='nice',type='int')
par.add_option('-x',help='Exit when the script finishes',dest='exitAfter',action='store_true')
par.add_option('-v',help='Increase logging verbosity; first occurence sets default logging level to info, second to debug, third to trace.'+
	('' if 'log4cxx' in features else " (Since this build doesn't use log4cxx, this option will only have effect if repeated twice (-vv), equivalent to setting YADE_DEBUG environment variable)"),action='count',dest='verbosity')
if debug:
	par.add_option('--no-gdb',help='Do not show backtrace when yade crashes.',dest='noGdb',action='store_true',)
par.add_option('-n',help="Run without graphical interface (equivalent to unsetting the DISPLAY environment variable)",dest='nogui',action='store_true')
par.add_option('--generate-manpage',help="Generate man page documenting this program and exit",dest='manpage',metavar='FILE')
par.add_option('--rebuild',help="Re-run build in the source directory, then run the updated yade with the same command line except --rebuild. The build profile for this build (${profile}) and its stored parameters will be used.",dest='rebuild',action='store_true')
par.disable_interspersed_args()

opts,args=par.parse_args()

# re-build yade so that the binary is up-to-date
if opts.rebuild:
	import subprocess
	# rebuild
	sourceRoot,profile='${sourceRoot}','${profile}' # replaced at install-time
	cmd=['scons','-Q','-C',sourceRoot,'profile=%s'%profile]
	print 'Rebuilding yade using',' '.join(cmd)
	if subprocess.call(cmd): raise RuntimeError('Error rebuilding Yade (--rebuild).')
	# run ourselves
	argv=[v for v in sys.argv if v!='--rebuild']
	print 'Running yade using',' '.join(argv)
	sys.exit(subprocess.call(argv))

# c++ boot code checks for YADE_DEBUG at some places; debug verbosity is equivalent
# do this early, to have debug messages in the boot code (plugin registration etc)
if opts.verbosity>1: os.environ['YADE_DEBUG']='1'

# this must be done before loading yade libs ("import yade" below)
# has no effeect after libgomp initializes
if opts.threads: os.environ['OMP_NUM_THREADS']=str(opts.threads)

sys.stderr.write('Welcome to Yade '+version+'\n')

# initialization and c++ plugins import
import yade
# other parts we will need soon
import yade.config
import yade.wrapper
import yade.log
import yade.system

# continue option processing

if opts.updateScripts:
	yade.system.updateScripts(args)
	sys.exit(0)
if opts.manpage:
	import yade.manpage
	yade.manpage.generate_manpage(par,yade.config.metadata,opts.manpage,section=1,seealso='yade%s-multi (1)'%suffix)
	print 'Manual page %s generated.'%opts.manpage
	sys.exit(0)
if opts.nice:
	os.nice(opts.nice)
if yade.config.debug and opts.noGdb:
	yade.wrapper.Omega().disableGdb()
if 'log4cxx' in yade.config.features and opts.verbosity:
	yade.log.setLevel('',[yade.log.INFO,yade.log.DEBUG,yade.log.TRACE][min(opts.verbosity,2)])

# modify sys.argv in-place so that it can be handled by userSession
sys.argv=yade.runtime.argv=args
yade.runtime.opts=opts

from yade import *
from math import *

def userSession(qt3=False,qt4=False):
	# prepare nice namespace for users
	import yade
	import sys
	if len(sys.argv)>0:
		arg0=sys.argv[0]
		if qt3 or qt4: yade.qt.Controller();
		if sum(bool(arg0.endswith(ext)) for ext in ('.xml','.xml.bz2','.xml.gz','.yade','.yade.gz','.yade.bz2','.bin','.bin.gz','.bin.bz2'))>0:
			if len(sys.argv)>1: raise RuntimeError('Extra arguments to saved simulation to run: '+' '.join(sys.argv[1:]))
			sys.stderr.write("Running simulation "+arg0+'\n')
			O=yade.wrapper.Omega(); O.load(arg0); O.run()
		if arg0.endswith('.py'):
			def runScript(script):
				sys.stderr.write("Running script "+arg0+'\n')
				try:
					execfile(script,globals())
				except SystemExit: raise
				except: # all other exceptions
					import traceback
					traceback.print_exc()
					if yade.runtime.opts.exitAfter: sys.exit(1)
				if yade.runtime.opts.exitAfter: sys.exit(0)
			#if qt4:
			#	class RunScriptThread(QThread):
			#		def __init__(self,script): QThread.__init__(self); self.script=script
			#		def run(self): runScript(self.script)
			#	worker=RunScriptThread(arg0)
			#	worker.start()
			#	print 'worker started'
			#else:
			runScript(arg0)
	# show python console
	if 1:
		from IPython.Shell import IPShellEmbed
		ipshell=IPShellEmbed(
			#exit_msg='Bye.',
			banner='[[ ^L clears screen, ^U kills line. '+
				', '.join((['F12 controller','F11 3d view','F10 both','F9 generator'] if (qt3 or qt4) else [])+['F8 plot'])+'. ]]',
			rc_override=dict( # ipython options, see e.g. http://www.cv.nrao.edu/~rreid/casa/tips/ipy_user_conf.py
				prompt_in1='Yade [\#]: ',
				prompt_in2='     .\D.: ',
				prompt_out=" ->  [\#]: ",
				separate_in='0',
				separate_out='0',
				separate_out2='0',
				#execfile=[prefix+'/lib/yade'+suffix+'/py/yade/ipython.py'],
				readline_parse_and_bind=[
					'tab: complete',
					# only with the gui
					# the escape codes might not work on non-linux terminals.
					]
					+(['"\e[24~": "\C-Uyade.qt.Controller();\C-M"','"\e[23~": "\C-Uyade.qt.View();\C-M"','"\e[21~": "\C-Uyade.qt.Controller(), yade.qt.View();\C-M"','"\e[20~": "\C-Uyade.qt.Generator();\C-M"'] if (qt3 or qt4) else []) #F12,F11,F10,F9
					+['"\e[19~": "\C-Uimport yade.plot; yade.plot.plot();\C-M"', #F8
					'"\e[A": history-search-backward', '"\e[B": history-search-forward', # incremental history forward/backward
					]
			)
		)
		ipshell()
		# save history -- a workaround for atexit handlers not being run (why?)
		# http://lists.ipython.scipy.org/pipermail/ipython-user/2008-September/005839.html
		import IPython.ipapi
		IPython.ipapi.get().IP.atexit_operations()

## run userSession in a way corresponding to the features we use:
gui=None
if 'qt3' in features: gui='qt3'
if 'qt4' in features: gui='qt4'
if opts.nogui: gui=None
if gui:
	import Xlib.display
	# PyQt4's QApplication does exit(1) if it is unable to connect to the display
	# we however want to handle this gracefully, therefore
	# we test the connection with bare xlib first, which merely raises DisplayError
	try:
		Xlib.display._BaseDisplay(); # contrary to display.Display, _BaseDisplay does not check for extensions and that avoids spurious message "Xlib.protocol.request.QueryExtension" (bug?)
	except Xlib.error.DisplayError:
		gui=None

# run remote access things, before actually starting the user session
from yade import remote
yade.remote.useQThread=(gui=='qt4')
yade.remote.runServers()

if gui==None:
	userSession()
elif gui=='qt3':
	# raises exception if unable to open the display, but that should have been handled above already
	import yade.qt
	userSession(qt3=True)
elif gui=='qt4':
	import PyQt4
	from PyQt4 import QtGui
	from PyQt4.QtCore import *
	import yade.qt # this yade.qt is different from the one that comes with qt3
	qapp=QtGui.QApplication(sys.argv)
	userSession(qt4=True)
O.exitNoBacktrace()

