/*************************************************************************
*  Copyright (C) 2004 by Olivier Galizzi                                 *
*  olivier.galizzi@imag.fr                                               *
*  Copyright (C) 2004 by Janek Kozicki                                   *
*  cosurgi@berlios.de                                                    *
*                                                                        *
*  This program is free software; it is licensed under the terms of the  *
*  GNU General Public License v2 or later. See file LICENSE for details. *
*************************************************************************/

#include "NewtonsForceLaw.hpp"
#include "ParticleParameters.hpp"
#include "RigidBodyParameters.hpp"
#include "Force.hpp"


void NewtonsForceLaw::go( const shared_ptr<PhysicalAction>& a
			, const shared_ptr<PhysicalParameters>& b
			, const Body* bb)
{
	Force * af = YADE_CAST<Force*>(a.get());
	ParticleParameters * p = YADE_CAST<ParticleParameters*>(b.get());
	
	//FIXME : should be += and we should add an Engine that reset acceleration at the beginning
	// if another PhysicalAction also acts on acceleration then we are overwritting it here
	//
	// currently this is not the case, because there is only one
	// PhysicalAction that influences acceleration: Force
	// 
	// If another PhysicalAction will be added, that works on acceleration,
	// then above will have to be fixed. And example of such action is: Acceleration
	//
	

	// TODO: remove debugging stuff from the following
	// normal behavior of a standalone particle or a clump itself
	if (bb->isStandalone()) p->acceleration=af->force/p->mass;
	else if (bb->isClump()) {
		// accel for clump reset in Clump::moveMembers, called by ClumpMemberMover engine
		p->acceleration+=af->force/p->mass;
	}
	else{ // force applied to a clump member is applied to clump itself
		const shared_ptr<Body>& clump(Body::byId(bb->clumpId));
		RigidBodyParameters* clumpRBP=YADE_CAST<RigidBodyParameters*>(clump->physicalParameters.get());
		// accels reset by Clump::moveMembers in last iteration
		clumpRBP->acceleration+=af->force/clumpRBP->mass;
		clumpRBP->angularAcceleration+=diagDiv((b->se3.position-clumpRBP->se3.position).Cross(af->force),clumpRBP->inertia); //acceleration from torque generated by the force WRT particle centroid on the clump centroid
	}
}


YADE_PLUGIN();
