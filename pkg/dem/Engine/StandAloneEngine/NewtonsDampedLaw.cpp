/*************************************************************************
 Copyright (C) 2008 by Bruno Chareyre		                         *
*  bruno.chareyre@hmg.inpg.fr      					 *
*                                                                        *
*  This program is free software; it is licensed under the terms of the  *
*  GNU General Public License v2 or later. See file LICENSE for details. *
*************************************************************************/

#include"NewtonsDampedLaw.hpp"
#include<yade/core/MetaBody.hpp>
#include<yade/pkg-common/RigidBodyParameters.hpp>
#include<yade/pkg-common/VelocityBins.hpp>
#include<yade/lib-base/yadeWm3Extra.hpp>
#include<yade/pkg-dem/Clump.hpp>

YADE_PLUGIN((NewtonsDampedLaw));
void NewtonsDampedLaw::cundallDamp(const Real& dt, const Vector3r& f, const Vector3r& velocity, Vector3r& acceleration, const Vector3r& m, const Vector3r& angularVelocity, Vector3r& angularAcceleration){
	for(int i=0; i<3; i++){
		angularAcceleration[i]*= 1 - damping*Mathr::Sign ( m[i]*(angularVelocity[i] + (Real) 0.5 *dt*angularAcceleration[i]) );
		acceleration       [i]*= 1 - damping*Mathr::Sign ( f[i]*(velocity       [i] + (Real) 0.5 *dt*acceleration       [i]) );
	}
}

void NewtonsDampedLaw::handleClumpMember(MetaBody* ncb, const body_id_t memberId, RigidBodyParameters* clumpRBP){
	const shared_ptr<Body>& b=Body::byId(memberId,ncb);
	assert(b->isClumpMember());
	RigidBodyParameters* rb=YADE_CAST<RigidBodyParameters*>(b->physicalParameters.get());
	const Vector3r& m=ncb->bex.getTorque(memberId); const Vector3r& f=ncb->bex.getForce(memberId);
	Vector3r diffClumpAccel=f/clumpRBP->mass;
	// angular acceleration from: normal torque + torque generated by the force WRT particle centroid on the clump centroid
	Vector3r diffClumpAngularAccel=diagDiv(m,clumpRBP->inertia)+diagDiv((rb->se3.position-clumpRBP->se3.position).Cross(f),clumpRBP->inertia); 
	// damp increment of accels on the clump, using velocities of the clump MEMBER
	cundallDamp(ncb->dt,f,rb->velocity,diffClumpAccel,m,rb->angularVelocity,diffClumpAngularAccel);
	// clumpRBP->{acceleration,angularAcceleration} are reset byt Clump::moveMembers, it is ok to just increment here
	clumpRBP->acceleration+=diffClumpAccel;
	clumpRBP->angularAcceleration+=diffClumpAngularAccel;
	if(haveBins) velocityBins->binVelSqUse(memberId,VelocityBins::getBodyVelSq(rb));
	#ifdef YADE_OPENMP
		Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,rb->velocity.SquaredLength());
	#else
		maxVelocitySq=max(maxVelocitySq,rb->velocity.SquaredLength());
	#endif
}

void NewtonsDampedLaw::action(MetaBody * ncb)
{
	ncb->bex.sync();
	Real dt=Omega::instance().getTimeStep();
	maxVelocitySq=-1;
	haveBins=(bool)velocityBins;
	if(haveBins) velocityBins->binVelSqInitialize();

	#ifdef YADE_OPENMP
		FOREACH(Real& thrMaxVSq, threadMaxVelocitySq) { thrMaxVSq=0; }
		const BodyContainer& bodies=*(ncb->bodies.get());
		const long size=(long)bodies.size();
		#pragma omp parallel for schedule(static)
		for(long _id=0; _id<size; _id++){
			const shared_ptr<Body>& b(bodies[_id]);
	#else
		FOREACH(const shared_ptr<Body>& b, *ncb->bodies){
	#endif
			if(!b) continue;
			RigidBodyParameters* rb = YADE_CAST<RigidBodyParameters*>(b->physicalParameters.get());
			const body_id_t& id=b->getId();
			// clump members are non-dynamic; we only get their velocities here
			if (!b->isDynamic || b->isClumpMember()){
				// FIXME: duplicated code from below; awaits https://bugs.launchpad.net/yade/+bug/398089 to be solved
				if(haveBins) {velocityBins->binVelSqUse(id,VelocityBins::getBodyVelSq(rb));}
				#ifdef YADE_OPENMP
					Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,rb->velocity.SquaredLength());
				#else
					maxVelocitySq=max(maxVelocitySq,rb->velocity.SquaredLength());
				#endif
				continue;
			}
			const Vector3r& m=ncb->bex.getTorque(id); const Vector3r& f=ncb->bex.getForce(id);

			if (b->isStandalone()){
				rb->acceleration=f/rb->mass;
				rb->angularAcceleration=diagDiv(m,rb->inertia);
				cundallDamp(dt,f,rb->velocity,rb->acceleration,m,rb->angularVelocity,rb->angularAcceleration);
			}
			else if (b->isClump()){
				rb->acceleration=rb->angularAcceleration=Vector3r::ZERO; // to make sure; should be reset in Clump::moveMembers
				// sum force on clump memebrs, add them to the clump itself
				FOREACH(Clump::memberMap::value_type mm, static_cast<Clump*>(b.get())->members){
					handleClumpMember(ncb,mm.first,rb);
				}
				// at this point, forces from clump members are already summed up, this is just for forces applied to clump proper, if there are such
				Vector3r dLinAccel=f/rb->mass, dAngAccel=diagDiv(m,rb->inertia);
				cundallDamp(dt,f,rb->velocity,dLinAccel,m,rb->angularVelocity,dAngAccel);
				rb->acceleration+=dLinAccel;
				rb->angularAcceleration+=dAngAccel;
			}

			// blocking DOFs
			if(rb->blockedDOFs==PhysicalParameters::DOF_NONE){
				rb->angularVelocity=rb->angularVelocity+dt*rb->angularAcceleration;
				rb->velocity=rb->velocity+dt*rb->acceleration;
			} else if(rb->blockedDOFs==PhysicalParameters::DOF_ALL){
				/* do nothing */
			} else {
				// handle more complicated cases here
				if((rb->blockedDOFs & PhysicalParameters::DOF_X)==0) rb->velocity[0]+=dt*rb->acceleration[0];
				if((rb->blockedDOFs & PhysicalParameters::DOF_Y)==0) rb->velocity[1]+=dt*rb->acceleration[1];
				if((rb->blockedDOFs & PhysicalParameters::DOF_Z)==0) rb->velocity[2]+=dt*rb->acceleration[2];
				if((rb->blockedDOFs & PhysicalParameters::DOF_RX)==0) rb->angularVelocity[0]+=dt*rb->angularAcceleration[0];
				if((rb->blockedDOFs & PhysicalParameters::DOF_RY)==0) rb->angularVelocity[1]+=dt*rb->angularAcceleration[1];
				if((rb->blockedDOFs & PhysicalParameters::DOF_RZ)==0) rb->angularVelocity[2]+=dt*rb->angularAcceleration[2];
			}

			// velocities are ready now, save maxima
				if(haveBins) {velocityBins->binVelSqUse(id,VelocityBins::getBodyVelSq(rb));}
				#ifdef YADE_OPENMP
					Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,rb->velocity.SquaredLength());
				#else
					maxVelocitySq=max(maxVelocitySq,rb->velocity.SquaredLength());
				#endif

			Vector3r axis = rb->angularVelocity;
			Real angle = axis.Normalize();
			Quaternionr q;
			q.FromAxisAngle ( axis,angle*dt );
			rb->se3.orientation = q*rb->se3.orientation;
			if(ncb->bex.getMoveRotUsed() && ncb->bex.getRot(id)!=Vector3r::ZERO){ Vector3r r(ncb->bex.getRot(id)); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); rb->se3.orientation=q*rb->se3.orientation; }
			rb->se3.orientation.Normalize();

			rb->se3.position += rb->velocity*dt + ncb->bex.getMove(id);

			if(b->isClump()) static_cast<Clump*>(b.get())->moveMembers();
	}
	#ifdef YADE_OPENMP
		FOREACH(const Real& thrMaxVSq, threadMaxVelocitySq) { maxVelocitySq=max(maxVelocitySq,thrMaxVSq); }
	#endif
	if(haveBins) velocityBins->binVelSqFinalize();
}

