/*************************************************************************
 Copyright (C) 2008 by Bruno Chareyre		                         *
*  bruno.chareyre@hmg.inpg.fr      					 *
*                                                                        *
*  This program is free software; it is licensed under the terms of the  *
*  GNU General Public License v2 or later. See file LICENSE for details. *
*************************************************************************/

#include"NewtonsDampedLaw.hpp"
#include<yade/core/MetaBody.hpp>
#include<yade/pkg-dem/Clump.hpp>
#include<yade/pkg-common/VelocityBins.hpp>
#include<yade/lib-base/yadeWm3Extra.hpp>

YADE_PLUGIN((NewtonsDampedLaw));
CREATE_LOGGER(NewtonsDampedLaw);
void NewtonsDampedLaw::cundallDamp(const Real& dt, const Vector3r& f, const Vector3r& velocity, Vector3r& acceleration, const Vector3r& m, const Vector3r& angularVelocity, Vector3r& angularAcceleration){
	for(int i=0; i<3; i++){
		angularAcceleration[i]*= 1 - damping*Mathr::Sign ( m[i]*(angularVelocity[i] + (Real) 0.5 *dt*angularAcceleration[i]) );
		acceleration       [i]*= 1 - damping*Mathr::Sign ( f[i]*(velocity       [i] + (Real) 0.5 *dt*acceleration       [i]) );
	}
}
void NewtonsDampedLaw::blockTranslateDOFs(unsigned blockedDOFs, Vector3r& v) {
	if(blockedDOFs==State::DOF_NONE) return;
	if(blockedDOFs==State::DOF_ALL)  v = Vector3r::ZERO;
	if((blockedDOFs & State::DOF_X)!=0) v[0]=0;
	if((blockedDOFs & State::DOF_Y)!=0) v[1]=0;
	if((blockedDOFs & State::DOF_Z)!=0) v[2]=0;
}
void NewtonsDampedLaw::blockRotateDOFs(unsigned blockedDOFs, Vector3r& v) {
	if(blockedDOFs==State::DOF_NONE) return;
	if(blockedDOFs==State::DOF_ALL)  v = Vector3r::ZERO;
	if((blockedDOFs & State::DOF_RX)!=0) v[0]=0;
	if((blockedDOFs & State::DOF_RY)!=0) v[1]=0;
	if((blockedDOFs & State::DOF_RZ)!=0) v[2]=0;
}
void NewtonsDampedLaw::handleClumpMember(MetaBody* ncb, const body_id_t memberId, State* clumpState){
	const shared_ptr<Body>& b=Body::byId(memberId,ncb);
	assert(b->isClumpMember());
	State* state=b->state.get();
	const Vector3r& m=ncb->bex.getTorque(memberId); const Vector3r& f=ncb->bex.getForce(memberId);
	Vector3r diffClumpAccel=f/clumpState->mass;
	// angular acceleration from: normal torque + torque generated by the force WRT particle centroid on the clump centroid
	Vector3r diffClumpAngularAccel=diagDiv(m,clumpState->inertia)+diagDiv((state->pos-clumpState->pos).Cross(f),clumpState->inertia); 
	// damp increment of accels on the clump, using velocities of the clump MEMBER
	cundallDamp(ncb->dt,f,state->vel,diffClumpAccel,m,state->angVel,diffClumpAngularAccel);
	// clumpState->{acceleration,angularAcceleration} are reset byt Clump::moveMembers, it is ok to just increment here
	clumpState->accel+=diffClumpAccel;
	clumpState->angAccel+=diffClumpAngularAccel;
	if(haveBins) velocityBins->binVelSqUse(memberId,VelocityBins::getBodyVelSq(state));
	#ifdef YADE_OPENMP
		Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,state->vel.SquaredLength());
	#else
		maxVelocitySq=max(maxVelocitySq,state->vel.SquaredLength());
	#endif
}

void NewtonsDampedLaw::handleStandAloneBody(MetaBody* ncb, const shared_ptr<Body>& b){
	Real dt=Omega::instance().getTimeStep();
	const body_id_t& id=b->getId();
	State* state=b->state.get();
	// acceleration
	const Vector3r& m=ncb->bex.getTorque(id); 
	const Vector3r& f=ncb->bex.getForce(id);
	state->accel=f/state->mass;
	state->angAccel=diagDiv(m,state->inertia);
	cundallDamp(dt,f,state->vel,state->accel,m,state->angVel,state->angAccel);
	// blocking DOFs
	blockTranslateDOFs( state->blockedDOFs, state->accel );
	blockRotateDOFs( state->blockedDOFs, state->angAccel );
	// translate equation
	state->vel+=dt*state->accel;
	state->pos+=state->vel*dt+ncb->bex.getMove(id);
	// rotate equation
	state->angVel+=dt*state->angAccel;
	Vector3r axis = state->angVel;
	Real angle = axis.Normalize();
	Quaternionr q;
	q.FromAxisAngle ( axis,angle*dt );
	state->ori = q*state->ori;
	if(ncb->bex.getMoveRotUsed() && ncb->bex.getRot(id)!=Vector3r::ZERO){ Vector3r r(ncb->bex.getRot(id)); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); state->ori=q*state->ori; }
	state->ori.Normalize();
}

void NewtonsDampedLaw::handleClumpBody(MetaBody* ncb, const shared_ptr<Body>& clump){
	const Real dt=Omega::instance().getTimeStep();
	State* clumpState=clump->state.get();
	const body_id_t id=clump->getId();
	clumpState->accel=clumpState->angAccel=Vector3r::ZERO; // to make sure; should be reset in Clump::moveMembers
	// sum of forces and torques
	const Vector3r& f=ncb->bex.getForce(id); 
	const Vector3r& m=ncb->bex.getTorque(id);
	Vector3r F(f), M(m);
	FOREACH(Clump::memberMap::value_type mm, static_cast<Clump*>(clump.get())->members){
		const body_id_t memberId=mm.first;
		const shared_ptr<Body>& b=Body::byId(memberId,ncb);
		assert(b->isClumpMember());
		State* state=b->state.get();
		const Vector3r& f=ncb->bex.getForce(memberId); const Vector3r& m=ncb->bex.getTorque(memberId);
		F+=f; M+=(state->pos-clumpState->pos).Cross(f)+m;
		if(haveBins) velocityBins->binVelSqUse(memberId,VelocityBins::getBodyVelSq(state));
		#ifdef YADE_OPENMP
			Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,state->vel.SquaredLength());
		#else
			maxVelocitySq=max(maxVelocitySq,state->vel.SquaredLength());
		#endif
	}
	//// sum force on clump memebrs, add them to the clump itself
	//FOREACH(Clump::memberMap::value_type mm, static_cast<Clump*>(b.get())->members){
		//handleClumpMember(ncb,mm.first,state);
	//}
	//// at this point, forces from clump members are already summed up, this is just for forces applied to clump proper, if there are such
	//Vector3r dLinAccel=f/state->mass, dAngAccel=diagDiv(m,state->inertia);
	//cundallDamp(dt,f,state->vel,dLinAccel,m,state->angVel,dAngAccel);
	//state->accel+=dLinAccel;
	//state->angAccel+=dAngAccel;

	// translate equation
	clumpState->accel=F/clumpState->mass; blockTranslateDOFs( clumpState->blockedDOFs, clumpState->accel );
	clumpState->vel+=dt*clumpState->accel; 
	clumpState->pos+=clumpState->vel*dt+ncb->bex.getMove(id);
	// rotate equation
	if (accRigidBodyRot) 
		accurateRigidBodyRotationIntegrator(ncb,clump,M);
	else {
		clumpState->angAccel=diagDiv(M,clumpState->inertia);
		blockRotateDOFs( clumpState->blockedDOFs, clumpState->angAccel );
		clumpState->angVel+=dt*clumpState->angAccel;
		Vector3r axis = clumpState->angVel;
		Real angle = axis.Normalize();
		Quaternionr q; q.FromAxisAngle ( axis,angle*dt );
		clumpState->ori = q*clumpState->ori;
		if(ncb->bex.getMoveRotUsed() && ncb->bex.getRot(id)!=Vector3r::ZERO){ Vector3r r(ncb->bex.getRot(id)); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); clumpState->ori=q*clumpState->ori; }
		clumpState->ori.Normalize();
	}
	static_cast<Clump*>(clump.get())->moveMembers();
}

void NewtonsDampedLaw::action(MetaBody * ncb)
{
	ncb->bex.sync();
	//Real dt=Omega::instance().getTimeStep();
	maxVelocitySq=-1;
	haveBins=(bool)velocityBins;
	if(haveBins) velocityBins->binVelSqInitialize();

	#ifdef YADE_OPENMP
		FOREACH(Real& thrMaxVSq, threadMaxVelocitySq) { thrMaxVSq=0; }
		const BodyContainer& bodies=*(ncb->bodies.get());
		const long size=(long)bodies.size();
		#pragma omp parallel for schedule(static)
		for(long _id=0; _id<size; _id++){
			const shared_ptr<Body>& b(bodies[_id]);
	#else
		FOREACH(const shared_ptr<Body>& b, *ncb->bodies){
	#endif
			if(!b) continue;
			State* state=b->state.get();
			const body_id_t& id=b->getId();
			// clump members are non-dynamic; we only get their velocities here
			if (!b->isDynamic || b->isClumpMember()){
				// FIXME: duplicated code from below; awaits https://bugs.launchpad.net/yade/+bug/398089 to be solved
				if(haveBins) {velocityBins->binVelSqUse(id,VelocityBins::getBodyVelSq(state));}
				#ifdef YADE_OPENMP
					Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,state->vel.SquaredLength());
				#else
					maxVelocitySq=max(maxVelocitySq,state->vel.SquaredLength());
				#endif
				continue;
			}

			if (b->isStandalone()){
				handleStandAloneBody(ncb,b);
				//const Vector3r& m=ncb->bex.getTorque(id); 
				//const Vector3r& f=ncb->bex.getForce(id);
				//state->accel=f/state->mass;
				//state->angAccel=diagDiv(m,state->inertia);
				//cundallDamp(dt,f,state->vel,state->accel,m,state->angVel,state->angAccel);
			}
			else if (b->isClump()){
				handleClumpBody(ncb,b);
				//if (accRigidBodyRot) {
					//accurateRigidBodyRotationIntegrator(ncb,b);
					//continue;
				//}
				//const Vector3r& m=ncb->bex.getTorque(id); 
				//const Vector3r& f=ncb->bex.getForce(id);
				//state->accel=state->angAccel=Vector3r::ZERO; // to make sure; should be reset in Clump::moveMembers
				//// sum force on clump memebrs, add them to the clump itself
				//FOREACH(Clump::memberMap::value_type mm, static_cast<Clump*>(b.get())->members){
					//handleClumpMember(ncb,mm.first,state);
				//}
				//// at this point, forces from clump members are already summed up, this is just for forces applied to clump proper, if there are such
				//Vector3r dLinAccel=f/state->mass, dAngAccel=diagDiv(m,state->inertia);
				//cundallDamp(dt,f,state->vel,dLinAccel,m,state->angVel,dAngAccel);
				//state->accel+=dLinAccel;
				//state->angAccel+=dAngAccel;
			}

			//// blocking DOFs
			////blockTranslateDOFs( state->blockedDOFs, state->accel );
			////state->vel+=+dt*state->accel;

			////blockRotateDOFs( state->blockedDOFs, state->angAccel );
			////state->angVel+=dt*state->angAccel;

			//if(state->blockedDOFs==State::DOF_NONE){
				//state->angVel+=dt*state->angAccel;
				//state->vel+=+dt*state->accel;
			//} else if(state->blockedDOFs==State::DOF_ALL){
				//[> do nothing <]
			//} else {
				//// handle more complicated cases here
				//if((state->blockedDOFs & State::DOF_X)==0) state->vel[0]+=dt*state->accel[0];
				//if((state->blockedDOFs & State::DOF_Y)==0) state->vel[1]+=dt*state->accel[1];
				//if((state->blockedDOFs & State::DOF_Z)==0) state->vel[2]+=dt*state->accel[2];
				//if((state->blockedDOFs & State::DOF_RX)==0) state->angVel[0]+=dt*state->angAccel[0];
				//if((state->blockedDOFs & State::DOF_RY)==0) state->angVel[1]+=dt*state->angAccel[1];
				//if((state->blockedDOFs & State::DOF_RZ)==0) state->angVel[2]+=dt*state->angAccel[2];
			//}

			// velocities are ready now, save maxima
				if(haveBins) {velocityBins->binVelSqUse(id,VelocityBins::getBodyVelSq(state));}
				#ifdef YADE_OPENMP
					Real& thrMaxVSq=threadMaxVelocitySq[omp_get_thread_num()]; thrMaxVSq=max(thrMaxVSq,state->vel.SquaredLength());
				#else
					maxVelocitySq=max(maxVelocitySq,state->vel.SquaredLength());
				#endif

			//Vector3r axis = state->angVel;
			//Real angle = axis.Normalize();
			//Quaternionr q;
			//q.FromAxisAngle ( axis,angle*dt );
			//state->ori = q*state->ori;
			//if(ncb->bex.getMoveRotUsed() && ncb->bex.getRot(id)!=Vector3r::ZERO){ Vector3r r(ncb->bex.getRot(id)); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); state->ori=q*state->ori; }
			//state->ori.Normalize();

			//Vector3r prevPos=state->pos;
			//state->pos += state->vel*dt + ncb->bex.getMove(id);

			//if(b->isClump()) static_cast<Clump*>(b.get())->moveMembers();
	}
	#ifdef YADE_OPENMP
		FOREACH(const Real& thrMaxVSq, threadMaxVelocitySq) { maxVelocitySq=max(maxVelocitySq,thrMaxVSq); }
	#endif
	if(haveBins) velocityBins->binVelSqFinalize();
}

void NewtonsDampedLaw::accurateRigidBodyRotationIntegrator(MetaBody* ncb, const shared_ptr<Body>& rb, const Vector3r& M){
	const Real dt=Omega::instance().getTimeStep();
	State* state=rb->state.get();
	const body_id_t id=rb->getId();
	//state->accel=state->angAccel=Vector3r::ZERO; // to make sure; should be reset in Clump::moveMembers
	//// sum of forces and torques
	//const Vector3r& f=ncb->bex.getForce(id); const Vector3r& m=ncb->bex.getTorque(id);
	//Vector3r F(f), M(m);
	//FOREACH(Clump::memberMap::value_type mm, static_cast<Clump*>(rb.get())->members){
		//const body_id_t memberId=mm.first;
		//const shared_ptr<Body>& b=Body::byId(memberId,ncb);
		//assert(b->isClumpMember());
		//State* bs=b->state.get();
		//const Vector3r& f=ncb->bex.getForce(memberId); const Vector3r& m=ncb->bex.getTorque(memberId);
		//F+=f; M+=(bs->pos-state->pos).Cross(f)+m;
	//}
	//// translate equation
	//state->accel=F/state->mass; blockTranslateDOFs( state->blockedDOFs, state->accel );
	//state->vel+=dt*state->accel; state->pos+=state->vel*dt+ncb->bex.getMove(id);
	// rotate equation
	Matrix3r A; state->ori.Conjugate().ToRotationMatrix(A); // rotation matrix from global to local r.f.
	const Vector3r l_n = state->prevAngMom + dt/2 * M; // global angular momentum at time n
	//Vector3r l_b_n = state->ori.Conjugate().Rotate(l_n); // local angular momentum at time n
	const Vector3r l_b_n = A*l_n; // local angular momentum at time n
	const Vector3r angVel_b_n = diagDiv(l_b_n,state->inertia); // local angular velocity at time n
	const Quaternionr dotQ_n=DotQ(angVel_b_n,state->ori); // dQ/dt at time n
	const Quaternionr Q_half = state->ori + dt/2 * dotQ_n; // Q at time n+1/2
	state->prevAngMom+=dt*M; // global angular momentum at time n+1/2
	//Vector3r l_b_half = state->ori.Conjugate().Rotate(state->prevAngMom); // local angular momentum at time n+1/2
	const Vector3r l_b_half = A*state->prevAngMom; // local angular momentum at time n+1/2
	Vector3r angVel_b_half = diagDiv(l_b_half,state->inertia); // local angular velocity at time n+1/2
	blockRotateDOFs( state->blockedDOFs, angVel_b_half );
	const Quaternionr dotQ_half=DotQ(angVel_b_half,Q_half); // dQ/dt at time n+1/2
	state->ori+=dt*dotQ_half; state->ori.Normalize(); // Q at time n+1
	state->angVel=state->ori.Rotate(angVel_b_half); // global angular velocity at time n+1/2
	//if(rb->isClump()) static_cast<Clump*>(rb.get())->moveMembers();
	//static_cast<Clump*>(rb.get())->moveMembers();

	LOG_TRACE(//"\nforce: " << F << 
		" torque: " << M
		<< "\nglobal angular momentum at time n: " << l_n
		<< "\nlocal angular momentum at time n:  " << l_b_n
		<< "\nlocal angular velocity at time n:  " << angVel_b_n
		<< "\ndQ/dt at time n:                   " << dotQ_n
		<< "\nQ at time n+1/2:                   " << Q_half
		<< "\nglobal angular momentum at time n+1/2: " << state->prevAngMom
		<< "\nlocal angular momentum at time n+1/2:  " << l_b_half
		<< "\nlocal angular velocity at time n+1/2:  " << angVel_b_half
		<< "\ndQ/dt at time n+1/2:                   " << dotQ_half
		<< "\nQ at time n+1:                         " << state->ori
		<< "\nglobal angular velocity at time n+1/2: " << state->angVel
	);
}
	
Quaternionr NewtonsDampedLaw::DotQ(const Vector3r& angVel, const Quaternionr& Q){
	Quaternionr dotQ(Quaternionr::ZERO);
	dotQ[0] = (-Q[1]*angVel[0]-Q[2]*angVel[1]-Q[3]*angVel[2])/2;
	dotQ[1] = ( Q[0]*angVel[0]-Q[3]*angVel[1]+Q[2]*angVel[2])/2;
	dotQ[2] = ( Q[3]*angVel[0]+Q[0]*angVel[1]-Q[1]*angVel[2])/2;
	dotQ[3] = (-Q[2]*angVel[0]+Q[1]*angVel[1]+Q[0]*angVel[2])/2;
	return dotQ;
}
