#!/usr/bin/env python
# encoding: utf-8
#
# portions © 2008 Václav Šmilauer <eudoxos@arcig.cz>

import os, sys, thread, time, logging, pipes

class JobInfo():
	def __init__(self,num,id,command,log,nSlots):
		self.started,self.finished,self.duration,self.exitStatus=None,None,None,None
		self.command=command; self.num=num; self.log=log; self.id=id; self.nSlots=nSlots
		self.status='PENDING'
		self.threadNum=None
	def saveInfo(self):
		log=file(self.log,'a')
		log.write("""
=================== JOB SUMMARY ================
id      : %s
status  : %d (%s)
duration: %s
command : %s
started : %s
finished: %s
"""%(self.id,self.exitStatus,'OK' if self.exitStatus==0 else 'FAILED',self.duration,self.command,time.asctime(time.localtime(self.started)),time.asctime(time.localtime(self.finished))));
		log.close()
	def htmlStats(self):
		ret='<tr>'
		ret+='<td>%s</td>'%self.id
		if self.status=='PENDING': ret+='<td bgcolor="grey">(pending)</td>'
		elif self.status=='RUNNING': ret+='<td bgcolor="yellow">%s</td>'%t2hhmmss(time.time()-self.started)
		elif self.status=='DONE': ret+='<td bgcolor="%s">%s</td>'%('green' if self.exitStatus==0 else 'red',self.duration)
		ret+='<td>%s</td>'%self.command
		ret+='<td>%d</td>'%self.nSlots
		ret+='</tr>'
		return ret
def t2hhmmss(dt): return '%02d:%02d:%02d'%(dt//3600,(dt%3600)//60,(dt%60))

def globalHtmlStats():
	t0=min([j.started for j in jobs if j.started!=None])
	ret='<p>Running %s, since %s.</p>'%(t2hhmmss(time.time()-t0),time.ctime(t0))
	ret+='<h3>Jobs</h3>'
	nFailed=len([j for j in jobs if j.status=='DONE' and j.exitStatus!=0])
	ret+='<p><b>%d</b> total, <b>%d</b> <span style="background-color:yellow">running</span>, <b>%d</b> <span style="background-color:green">done</span>%s</p>'%(len(jobs),len([j for j in jobs if j.status=='RUNNING']), len([j for j in jobs if j.status=='DONE']),' (<b>%d <span style="background-color:red"><b>failed</b></span>)'%nFailed if nFailed>0 else '')
	return ret

from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
import socket
class HttpStatsServer(BaseHTTPRequestHandler):
	def do_GET(self):
		self.send_response(200)
		self.send_header('Content-type','text/html')
		self.send_header('refresh','5')
		self.end_headers()
		self.wfile.write('<HTML><TITLE>Yade-multi overview</TITLE><BODY>')
		self.wfile.write(globalHtmlStats())
		self.wfile.write('<TABLE border=1><tr><th>id</th><th>status</th><th>command</th><th>slots</th></tr>')
		for j in jobs:
			self.wfile.write(j.htmlStats())
		self.wfile.write('</TABLE></BODY></HTML>')
		return
	def log_request(self,req): pass
def runHttpStatsServer():
	try:
		server=HTTPServer(('',9080),HttpStatsServer)
		import thread; thread.start_new_thread(server.serve_forever,())
	except socket.error:
		print "WARN: Port 9080 occupied, not starting HTTP stats server"


def runJob(job):
	job.status='RUNNING'
	job.started=time.time();
	print '#%d (%s%s) started on %s'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,time.asctime())
	job.exitStatus=os.system(job.command)
	job.finished=time.time()
	dt=job.finished-job.started;
	job.duration=t2hhmmss(dt)
	strStatus='done   ' if job.exitStatus==0 else 'FAILED '
	job.status='DONE'
	print "#%d (%s%s) %s (exit status %d), duration %s, log %s"%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,strStatus,job.exitStatus,job.duration,job.log)
	job.saveInfo()
	
def runJobs(jobs,numSlots):
	running,pending=0,len(jobs)
	inf=1000000
	while (running>0) or (pending>0):
		pending,running,done=sum([j.nSlots for j in jobs if j.status=='PENDING']),sum([j.nSlots for j in jobs if j.status=='RUNNING']),sum([j.nSlots for j in jobs if j.status=='DONE'])
		#print [j.status for j in jobs]
		freeSlots=numSlots-running
		minRequire=min([inf]+[j.nSlots for j in jobs if j.status=='PENDING'])
		if minRequire==inf: minRequire=0
		#print pending,'pending;',running,'running;',done,'done;',freeSlots,'free;',minRequire,'min'
		if minRequire>freeSlots and running==0:
			freeSlots=minRequire
		for j in [j for j in jobs if j.status=='PENDING']:
			if j.nSlots<=freeSlots:
				thread.start_new_thread(runJob,(j,))
				break
		time.sleep(.5)


import sys,re,optparse
def getNumCores(): return len([l for l in open('/proc/cpuinfo','r') if l.find('processor')==0])

parser=optparse.OptionParser(usage='%prog [options] TABLE SIMULATION.py\n\n  %prog runs yade simulation multiple times with different parameters.\n  See http://yade.wikia.com/wiki/ScriptParametricStudy for details.')
parser.add_option('-j',dest='maxJobs',type='int',help="Maximum number of simultaneous jobs to run (default: number of cores, i.e. %d)"%getNumCores(),metavar='NUM',default=getNumCores())
parser.add_option('--log',dest='logFormat',help='Format of log files -- must contain a % or @, which will be replaced by line number or by description column respectively (default: SIMULATION.@.log)',metavar='FORMAT')
parser.add_option('-l','--lines',dest='lineList',help='Lines of TABLE to use, in the format 2,3-5,8,11-13 (default: all available lines in TABLE)',metavar='LIST')
parser.add_option('--nice',dest='nice',type='int',help='Nice value of spawned jobs (default: 10)',default=10)
parser.add_option('--executable',dest='executable',help='Name of the program to run (default: %s)'%sys.argv[0][:-6],default=sys.argv[0][:-6],metavar='FILE') ## strip the '-multi' extension
parser.add_option('--gnuplot',dest='gnuplotOut',help='Gnuplot file where gnuplot from all jobs should be put together',default=None,metavar='FILE')
parser.add_option('--dry-run',action='store_true',dest='dryRun',help='Do not actually run (useful for getting gnuplot only, for instance)',default=False)
opts,args=parser.parse_args()
logFormat,lineList,maxJobs,nice,executable,gnuplotOut,dryRun=opts.logFormat,opts.lineList,opts.maxJobs,opts.nice,opts.executable,opts.gnuplotOut,opts.dryRun

if len(args)!=2:
	#print "Exactly two non-option arguments must be specified -- parameter table and script to be run.\n"
	parser.print_help()
	sys.exit(1)
table,simul=args[0:2]
if not logFormat: logFormat=(simul[:-3] if simul[-3:]=='.py' else simul)+".@.log"
if (not '%' in logFormat) and ('@' not in logFormat): raise StandardError("Log string must contain at least one of `%', `@'")

print "Will run `%s' on `%s' with nice value %d, output redirected to `%s', %d jobs at a time."%(executable,simul,nice,logFormat,maxJobs)

ll=[re.sub('\s*#.*','',l) for l in ['']+open(table,'r').readlines()] # remove comments
availableLines=[i for i in range(len(ll)) if not re.match(r'^\s*(#.*)?$',ll[i][:-1])]
# first non-blank line are column headings
headings=ll[availableLines[0]].split()
availableLines=availableLines[1:]
# read actual data
values={}
for l in availableLines:
	val={}
	for i in range(len(headings)):
		val[i]=ll[l].split()[i]
	values[l]=val

print "Will use table `%s', with available lines"%(table),', '.join([str(i) for i in availableLines])+'.'

if lineList:
	useLines=[]
	def numRange2List(s):
		ret=[]
		for l in s.split(','):
			if "-" in l: ret+=range(*[int(s) for s in l.split('-')]); ret+=[ret[-1]+1]
			else: ret+=[int(l)]
		return ret
	useLines0=numRange2List(lineList)
	for l in useLines0:
		if l not in availableLines: logging.warn('skipping unavailable line %d that was requested from the command line.'%l)
		elif l==1: logging.warn("WARNING: skipping line 1 that should contain variable labels")
		else: useLines+=[l]
else: useLines=availableLines
try:
	idColumn=headings.index('description')
	idStrings={}
	for i in useLines: idStrings[i]=values[i][idColumn] # textual descripion of respective lines 
	print "Will use lines ",', '.join([str(i)+' (%s)'%idStrings[i] for i in useLines])+'.'
	#print idStrings
except ValueError:
	# try to get idStrings from columns with trailing !
	bangCols=[i for i,h in enumerate(headings) if h[-1]=='!']
	if len(bangCols)==0:
		print 'WARN: no headings with trailing !, will use all of them for description'
		bangCols=range(len(headings))
	for i in range(len(headings)):
		if headings[i][-1]=='!': headings[i]=headings[i][:-1]
	idStrings={}
	for i in useLines:
		newIdBase=','.join( headings[col]+'='+('%g'%values[i][col] if isinstance(values[i][col],float) else str(values[i][col])) for col in bangCols)
		newId=newIdBase; j=1
		while newId in idStrings.values():
			newId=newIdBase+'_%d_'%j; j+=1
		idStrings[i]=newId.replace("'",'').replace('"','')
	print "Will use lines ",', '.join([str(i) for i in useLines])+'.'


jobs=[]
for i,l in enumerate(useLines):
	logFile=logFormat.replace('%',str(l))
	if idStrings: logFile=logFile.replace('@',idStrings[l])
	else: logFile=logFile.replace('@',str(l))
	logFile=logFile.replace('!','')
	envVars=[]
	nSlots=1
	for col,head in enumerate(headings):
		if head=='!EXEC': executable=values[l][col]
		if head=='!OMP_NUM_THREADS':
			nSlots=int(values[l][col]); maxCpu=getNumCores()
		if head[0]=='!': envVars+=['%s=%s'%(head[1:],values[l][col])]
	if nSlots>maxJobs: logging.warning('WARNING: job #%d wants %d slots but only %d are available'%(i,nSlots,maxJobs))
	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d %s nice -n %d %s -N PythonUI -- -n -x %s > %s 2>&1'%(table,l,' '.join(envVars),nice,executable,simul,pipes.quote(logFile)),logFile,nSlots))

print "Job summary:"
for job in jobs:
	print '   #%d (%s%s):'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots),job.command

runHttpStatsServer()

# OK, go now
if not dryRun: runJobs(jobs,maxJobs)

print 'All jobs finished.'

# for easy grepping in logfiles:
print 'Log files:'
for job in jobs: print job.log,
print

if not gnuplotOut:
	print 'Bye.'
else:
	print 'Assembling gnuplot files…'
	for job in jobs:
		for l in file(job.log):
			if l.startswith('gnuplot '):
				job.plot=l.split()[1]
				break
	preamble,plots='',[]
	for job in jobs:
		if not 'plot' in job.__dict__:
			print "WARN: No plot found for job "+job.id
			continue
		for l in file(job.plot):
			if l.startswith('plot'):
				# attempt to parse the plot line
				ll=l.split(' ',1)[1][:-1] # rest of the line, without newline
				# replace title 'something' with title 'description: something'
				ll,nn=re.subn(r'title\s+[\'"]([^\'"]*)[\'"]',r'title "'+job.id+r': \1"',ll)
				if nn==0:
					logging.error("Plot line in "+job.plot+" not parsed (skipping): "+ll)
				plots.append(ll)
				break
			if not plots: # first plot, copy all preceding lines
				preamble+=l
	gp=file(gnuplotOut,'w')
	gp.write(preamble)
	gp.write('plot '+','.join(plots))
	print "gnuplot",gnuplotOut
	print "Plot written, bye."
