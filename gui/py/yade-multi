#!/usr/bin/env python
# encoding: utf-8
#
# portions © 2008 Václav Šmilauer <eudoxos@arcig.cz>

import os, sys, thread, time,logging

class JobInfo():
	def __init__(self,num,id,command,log,nSlots):
		self.started,self.finished,self.duration,self.exitStatus=None,None,None,None
		self.command=command; self.num=num; self.log=log; self.id=id; self.nSlots=nSlots
		self.status='PENDING'
		self.threadNum=None
	def saveInfo(self):
		log=file(self.log,'a')
		log.write("""
=================== JOB SUMMARY ================
id      : %s
status  : %d (%s)
duration: %s
command : %s
started : %s
finished: %s
"""%(self.id,self.exitStatus,'OK' if self.exitStatus==0 else 'FAILED',self.duration,self.command,time.asctime(time.localtime(self.started)),time.asctime(time.localtime(self.finished))));
		log.close()



def runJob(job):
	job.status='RUNNING'
	job.started=time.time();
	print '#%d (%s%s) started on %s'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,time.asctime())
	job.exitStatus=os.system(job.command)
	job.finished=time.time()
	dt=job.finished-job.started;
	job.duration='%02d:%02d:%02d'%(dt//3600,(dt%3600)//60,(dt%60))
	strStatus='done   ' if job.exitStatus==0 else 'FAILED '
	job.status='DONE'
	print "#%d (%s%s) %s (exit status %d), duration %s, log %s"%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,strStatus,job.exitStatus,job.duration,job.log)
	job.saveInfo()
	
def runJobs(jobs,numSlots):
	running,pending=0,len(jobs)
	inf=1000000
	while (running>0) or (pending>0):
		pending,running,done=sum([j.nSlots for j in jobs if j.status=='PENDING']),sum([j.nSlots for j in jobs if j.status=='RUNNING']),sum([j.nSlots for j in jobs if j.status=='DONE'])
		#print [j.status for j in jobs]
		freeSlots=numSlots-running
		minRequire=min([inf]+[j.nSlots for j in jobs if j.status=='PENDING'])
		if minRequire==inf: minRequire=0
		#print pending,'pending;',running,'running;',done,'done;',freeSlots,'free;',minRequire,'min'
		if minRequire>freeSlots and running==0:
			freeSlots=minRequire
		for j in [j for j in jobs if j.status=='PENDING']:
			if j.nSlots<=freeSlots:
				thread.start_new_thread(runJob,(j,))
				break
		time.sleep(.5)


import sys,re,optparse
def getNumCores(): return len([l for l in open('/proc/cpuinfo','r') if l.find('processor')==0])

parser=optparse.OptionParser(usage='%prog [options] TABLE SIMULATION.py\n\n  %prog runs yade simulation multiple times with different parameters.\n  See http://yade.wikia.com/wiki/ScriptParametricStudy for details.')
parser.add_option('-j',dest='maxJobs',type='int',help="Maximum number of simultaneous jobs to run (default: number of cores, i.e. %d)"%getNumCores(),metavar='NUM',default=getNumCores())
parser.add_option('--log',dest='logFormat',help='Format of log files -- must contain a % or @, which will be replaced by line number or by description column respectively (default: SIMULATION.@.log)',metavar='FORMAT')
parser.add_option('-l','--lines',dest='lineList',help='Lines of TABLE to use, in the format 2,3-5,8,11-13 (default: all available lines in TABLE)',metavar='LIST')
parser.add_option('--nice',dest='nice',type='int',help='Nice value of spawned jobs (default: 10)',default=10)
parser.add_option('--executable',dest='executable',help='Name of the program to run (default: %s)'%sys.argv[0][:-6],default=sys.argv[0][:-6],metavar='FILE') ## strip the '-multi' extension
parser.add_option('--gnuplot',dest='gnuplotOut',help='Gnuplot file where gnuplot from all jobs should be put together',default=None,metavar='FILE')
parser.add_option('--dry-run',action='store_true',dest='dryRun',help='Do not actually run (useful for getting gnuplot only, for instance)',default=False)
opts,args=parser.parse_args()
logFormat,lineList,maxJobs,nice,executable,gnuplotOut,dryRun=opts.logFormat,opts.lineList,opts.maxJobs,opts.nice,opts.executable,opts.gnuplotOut,opts.dryRun

if len(args)!=2:
	#print "Exactly two non-option arguments must be specified -- parameter table and script to be run.\n"
	parser.print_help()
	sys.exit(1)
table,simul=args[0:2]
if not logFormat: logFormat=(simul[:-3] if simul[-3:]=='.py' else simul)+".@.log"
if (not '%' in logFormat) and ('@' not in logFormat): raise StandardError("Log string must contain at least one of `%', `@'")

print "Will run `%s' on `%s' with nice value %d, output redirected to `%s', %d jobs at a time."%(executable,simul,nice,logFormat,maxJobs)

ll=[re.sub('\s*#.*','',l) for l in ['']+open(table,'r').readlines()] # remove comments
availableLines=[i for i in range(len(ll)) if not re.match(r'^\s*(#.*)?$',ll[i][:-1]) and i>1]

# read actual data
values={}
headings=ll[1].split()
for l in availableLines:
	val={}
	for i in range(len(headings)):
		val[i]=ll[l].split()[i]
	values[l]=val

print "Will use table `%s', with available lines"%(table),', '.join([str(i) for i in availableLines])+'.'

if lineList:
	useLines=[]
	def numRange2List(s):
		ret=[]
		for l in s.split(','):
			if "-" in l: ret+=range(*[int(s) for s in l.split('-')]); ret+=[ret[-1]+1]
			else: ret+=[int(l)]
		return ret
	useLines0=numRange2List(lineList)
	for l in useLines0:
		if l not in availableLines: logging.warn('skipping unavailable line %d that was requested from the command line.'%l)
		elif l==1: logging.warn("WARNING: skipping line 1 that should contain variable labels")
		else: useLines+=[l]
else: useLines=availableLines
try:
	idColumn=headings.index('description')
	idStrings={}
	for i in useLines: idStrings[i]=values[i][idColumn] # textual descripion of respective lines 
	print "Will use lines ",', '.join([str(i)+' (%s)'%idStrings[i] for i in useLines])+'.'
	#print idStrings
except ValueError:
	idColumn=None
	idStrings=None
	print "Will use lines ",', '.join([str(i) for i in useLines])+'.'


jobs=[]
for i,l in enumerate(useLines):
	logFile=logFormat.replace('%',str(l))
	if idStrings: logFile=logFile.replace('@',idStrings[l])
	else: logFile=logFile.replace('@',str(l))
	envVars=[]
	nSlots=1
	for col,head in enumerate(headings):
		if head=='!EXEC': executable=values[l][col]
		if head=='!OMP_NUM_THREADS': nSlots=int(values[l][col])
		if head[0]=='!': envVars+=['%s=%s'%(head[1:],values[l][col])]
	if nSlots>maxJobs: logging.warning('WARNING: job #%d wants %d slots but only %d are available'%(i,nSlots,maxJobs))
	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d %s nice -n %d %s -N PythonUI -- -n -x %s > %s 2>&1'%(table,l,' '.join(envVars),nice,executable,simul,logFile),logFile,nSlots))

print "Job summary:"
for job in jobs:
	print '   #%d (%s%s):'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots),job.command

# OK, go now
if not dryRun: runJobs(jobs,maxJobs)

print 'All jobs finished,',
if not gnuplotOut:
	print 'bye.'
else:
	print 'assembling gnuplot files…'
	for job in jobs:
		for l in file(job.log):
			if l.startswith('gnuplot '):
				job.plot=l.split()[1]
				break
	preamble,plots='',[]
	for job in jobs:
		if not 'plot' in job.__dict__:
			print "WARN: No plot found for job "+job.id
			continue
		for l in file(job.plot):
			if l.startswith('plot'):
				# attempt to parse the plot line
				ll=l.split(' ',1)[1][:-1] # rest of the line, without newline
				# replace title 'something' with title 'description: something'
				ll,nn=re.subn(r'title\s+[\'"]([^\'"]*)[\'"]',r'title "'+job.id+r': \1"',ll)
				if nn==0:
					logging.error("Plot line in "+job.plot+" not parsed (skipping): "+ll)
				plots.append(ll)
				break
			if not plots: # first plot, copy all preceding lines
				preamble+=l
	gp=file(gnuplotOut,'w')
	gp.write(preamble)
	gp.write('plot '+','.join(plots))
	print "Finished writing "+gnuplotOut+", bye."
