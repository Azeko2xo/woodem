#!/usr/bin/env python
# encoding: utf-8
#
# portions © 2008 Václav Šmilauer <eudoxos@arcig.cz>

import os, sys, thread, time

class JobInfo():
	def __init__(self,num,id,command,log,nSlots):
		self.started,self.finished,self.duration,self.exitStatus=None,None,None,None
		self.command=command; self.num=num; self.log=log; self.id=id; self.nSlots=nSlots
		self.status='PENDING'
		self.threadNum=None
	def saveInfo(self):
		log=file(self.log,'a')
		log.write("""
=================== JOB SUMMARY ================
id      : %s
status  : %d (%s)
duration: %s
command : %s
started : %s
finished: %s
"""%(self.id,self.exitStatus,'OK' if self.exitStatus==0 else 'FAILED',self.duration,self.command,time.asctime(time.localtime(self.started)),time.asctime(time.localtime(self.finished))));
		log.close()



def runJob(job):
	job.status='RUNNING'
	job.started=time.time();
	print '#%d (%s%s) started on %s'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,time.asctime())
	job.exitStatus=os.system(job.command)
	job.finished=time.time()
	dt=job.finished-job.started;
	job.duration='%02d:%02d:%02d'%(dt//3600,(dt%3600)//60,(dt%60))
	strStatus='done   ' if job.exitStatus==0 else 'FAILED '
	job.status='DONE'
	print "#%d (%s%s) %s (exit status %d), duration %s, log %s"%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots,strStatus,job.exitStatus,job.duration,job.log)
	job.saveInfo()
	
def runJobs(jobs,numSlots):
	running,pending=0,len(jobs)
	inf=1000000
	while (running>0) or (pending>0):
		pending,running,done=sum([j.nSlots for j in jobs if j.status=='PENDING']),sum([j.nSlots for j in jobs if j.status=='RUNNING']),sum([j.nSlots for j in jobs if j.status=='DONE'])
		#print [j.status for j in jobs]
		freeSlots=numSlots-running
		minRequire=min([inf]+[j.nSlots for j in jobs if j.status=='PENDING'])
		if minRequire==inf: minRequire=0
		#print pending,'pending;',running,'running;',done,'done;',freeSlots,'free;',minRequire,'min'
		if minRequire>freeSlots and running==0:
			freeSlots=minRequire
		for j in [j for j in jobs if j.status=='PENDING']:
			if j.nSlots<=freeSlots:
				thread.start_new_thread(runJob,(j,))
				break
		time.sleep(.5)


import sys,re,optparse
def getNumCores(): return len([l for l in open('/proc/cpuinfo','r') if l.find('processor')==0])

parser=optparse.OptionParser(usage='%prog [options] TABLE SIMULATION.py\n\n  %prog runs yade simulation multiple times with different parameters.\n  See http://yade.wikia.com/wiki/ScriptParametricStudy for details.')
parser.add_option('-j',dest='maxJobs',type='int',help="Maximum number of simultaneous jobs to run (default: number of cores, i.e. %d)"%getNumCores(),metavar='NUM',default=getNumCores())
parser.add_option('--log',dest='logFormat',help='Format of log files -- must contain a % or @, which will be replaced by line number or by description column respectively (default: SIMULATION.@.log)',metavar='FORMAT')
parser.add_option('-l','--lines',dest='lineList',help='Lines of TABLE to use, in the format 2,3-5,8,11-13 (default: all available lines in TABLE)',metavar='LIST')
parser.add_option('--nice',dest='nice',type='int',help='Nice value of spawned jobs (default: 10)',default=10)
parser.add_option('--executable',dest='executable',help='Name of the program to run (default: %s)'%sys.argv[0][:-6],default=sys.argv[0][:-6],metavar='FILE') ## strip the '-multi' extension
opts,args=parser.parse_args()
logFormat,lineList,maxJobs,nice,executable=opts.logFormat,opts.lineList,opts.maxJobs,opts.nice,opts.executable

if len(args)!=2:
	#print "Exactly two non-option arguments must be specified -- parameter table and script to be run.\n"
	parser.print_help()
	sys.exit(1)
table,simul=args[0:2]
if not logFormat: logFormat=(simul[:-3] if simul[-3:]=='.py' else simul)+".@.log"
if (not '%' in logFormat) and ('@' not in logFormat): raise StandardError("Log string must contain at least one of `%', `@'")

print "Will run `%s' on `%s' with nice value %d, output redirected to `%s', %d jobs at a time."%(executable,simul,nice,logFormat,maxJobs)

ll=['']+open(table,'r').readlines()
availableLines=[i for i in range(len(ll)) if not re.match(r'^\s*(#.*)?$',ll[i][:-1]) and i>1]

# read actual data
values={}
headings=ll[1].split()
for l in availableLines:
	val={}
	for i in range(len(headings)):
		val[i]=ll[l].split()[i]
	values[l]=val

print "Will use table `%s', with available lines"%(table),', '.join([str(i) for i in availableLines])+'.'

if lineList:
	useLines=[]
	def numRange2List(s):
		ret=[]
		for l in s.split(','):
			if "-" in l: ret+=range(*[int(s) for s in l.split('-')]); ret+=[ret[-1]+1]
			else: ret+=[int(l)]
		return ret
	useLines0=numRange2List(lineList)
	for l in useLines0:
		if l not in availableLines: print "WARNING: skipping unavailable line %d that was requested from the command line."%l
		elif l==1: print "WARNING: skipping line 1 that should contain variable labels"
		else: useLines+=[l]
else: useLines=availableLines
try:
	idColumn=headings.index('description')
	idStrings={}
	for i in useLines: idStrings[i]=values[i][idColumn] # textual descripion of respective lines 
	print "Will use lines ",', '.join([str(i)+' (%s)'%idStrings[i] for i in useLines])+'.'
	#print idStrings
except ValueError:
	idColumn=None
	idStrings=None
	print "Will use lines ",', '.join([str(i) for i in useLines])+'.'


jobs=[]
for i,l in enumerate(useLines):
	logFile=logFormat.replace('%',str(l))
	if idStrings: logFile=logFile.replace('@',idStrings[l])
	else: logFile=logFile.replace('@',str(l))
	envVars=[]
	nSlots=1
	for col,head in enumerate(headings):
		if head=='!EXEC': executable=values[l][col]
		if head=='!OMP_NUM_THREADS': nSlots=int(values[l][col])
		if head[0]=='!': envVars+=['%s=%s'%(head[1:],values[l][col])]
	if nSlots>maxJobs: print 'WARNING: job #%d wants %d slots but only %d are available'%(i,nSlots,maxJobs)
	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d %s nice -n %d %s -N PythonUI -- -n -x %s > %s 2>&1'%(table,l,' '.join(envVars),nice,executable,simul,logFile),logFile,nSlots))

print "Job summary:"
for job in jobs:
	print '   #%d (%s%s):'%(job.num,job.id,'' if job.nSlots==1 else '/%d'%job.nSlots),job.command

# OK, go now
runJobs(jobs,maxJobs)
print 'All jobs finished, bye.'
