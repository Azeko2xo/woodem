/*************************************************************************
*  Copyright (C) 2004 by Olivier Galizzi                                 *
*  olivier.galizzi@imag.fr                                               *
*  Copyright (C) 2004 by Janek Kozicki                                   *
*  cosurgi@berlios.de                                                    *
*                                                                        *
*  This program is free software; it is licensed under the terms of the  *
*  GNU General Public License v2 or later. See file LICENSE for details. *
*************************************************************************/

#include "NewtonsForceLaw.hpp"
#include "ParticleParameters.hpp"
#include "RigidBodyParameters.hpp"
#include "Force.hpp"


void NewtonsForceLaw::go( const shared_ptr<PhysicalAction>& a
			, const shared_ptr<PhysicalParameters>& b
			, const Body* bb)
{
	Force * af = dynamic_cast<Force*>(a.get());
	ParticleParameters * p = dynamic_cast<ParticleParameters*>(b.get());
	
	//FIXME : should be += and we should add an Engine that reset acceleration at the beginning
	// if another PhysicalAction also acts on acceleration then we are overwritting it here
	//
	// currently this is not the case, because there is only one
	// PhysicalAction that influences acceleration: Force
	// 
	// If another PhysicalAction will be added, that works on acceleration,
	// then above will have to be fixed. And example of such action is: Acceleration
	//
	
//	std::cout << bb->getId() << std::endl;
//	std::cout << a->getClassIndex() << " " << a->getClassName() << std::endl;
//	std::string ch;
//	std::cin >> ch;

	#ifdef HIGHLEVEL_CLUMPS
	if (bb->clumpId==Body::ID_NONE) p->acceleration = af->force/p->mass; // normal behavior of a standalone particle
	else{
		shared_ptr<Body> clump=Body::byId(bb->clumpId);
		RigidBodyParameters* clumpPP=dynamic_cast<RigidBodyParameters*>(clump->physicalParameters.get());
		/* TODO: the FIXME above still applies!!! */
		clumpPP->acceleration+=af->force/clumpPP->mass;
		clumpPP->angularAcceleration+=(b->se3.position-clumpPP->se3.position).Cross(af->force); //momentum generated by the force WRT particle centroid on the clump centroid
	}
	#else
		p->acceleration = af->force/p->mass;
	#endif
}


