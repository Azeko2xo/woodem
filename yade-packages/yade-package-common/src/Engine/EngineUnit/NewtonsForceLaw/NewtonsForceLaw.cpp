/*************************************************************************
*  Copyright (C) 2004 by Olivier Galizzi                                 *
*  olivier.galizzi@imag.fr                                               *
*  Copyright (C) 2004 by Janek Kozicki                                   *
*  cosurgi@berlios.de                                                    *
*                                                                        *
*  This program is free software; it is licensed under the terms of the  *
*  GNU General Public License v2 or later. See file LICENSE for details. *
*************************************************************************/

#include "NewtonsForceLaw.hpp"
#include "ParticleParameters.hpp"
#include "RigidBodyParameters.hpp"
#include "Force.hpp"


void NewtonsForceLaw::go( const shared_ptr<PhysicalAction>& a
			, const shared_ptr<PhysicalParameters>& b
			, const Body* bb)
{
	Force * af = dynamic_cast<Force*>(a.get());
	ParticleParameters * p = dynamic_cast<ParticleParameters*>(b.get());
	
	//! FIXME FIXME: the following seems to be no longer truth with PhysicalActionContainerReseter?!!
	
	//FIXME : should be += and we should add an Engine that reset acceleration at the beginning
	// if another PhysicalAction also acts on acceleration then we are overwritting it here
	//
	// currently this is not the case, because there is only one
	// PhysicalAction that influences acceleration: Force
	// 
	// If another PhysicalAction will be added, that works on acceleration,
	// then above will have to be fixed. And example of such action is: Acceleration
	//
	
//	std::cout << bb->getId() << std::endl;
//	std::cout << a->getClassIndex() << " " << a->getClassName() << std::endl;
//	std::string ch;
//	std::cin >> ch;

	#ifdef HIGHLEVEL_CLUMPS
	// TODO: remove debugging stuff from the following
	// normal behavior of a standalone particle or a clump itself
	if (bb->isStandalone() || bb->isClump()) {
		// FIXME: reset accel for standalones, just as original NewtonForceLaw does; for clumps, done in Clump::moveSubBodies
		if(bb->isStandalone()) p->acceleration=Vector3r(0,0,0);
		p->acceleration+=af->force/p->mass;
		//if(bb->isClump())cerr<<"##"<<bb->getId()<<"      : force="<<af->force<<", mass="<<p->mass<<", accel="<<p->acceleration<<endl; //", angularAcceleration="<<p->angularAcceleration<<endl;
	}
	else{
		shared_ptr<Body> clump=Body::byId(bb->clumpId);
		RigidBodyParameters* clumpRBP=dynamic_cast<RigidBodyParameters*>(clump->physicalParameters.get());
		/* TODO: the FIXME above still applies??!!! */
		//cerr<<"#"<<bb->getId()<<" orig (##"<<bb->clumpId<<"): acceleration="<<clumpRBP->acceleration<<", angularAcceleration="<<clumpRBP->angularAcceleration<<endl;
		clumpRBP->acceleration+=af->force/clumpRBP->mass;
		clumpRBP->angularAcceleration+=diagDiv((b->se3.position-clumpRBP->se3.position).Cross(af->force),clumpRBP->inertia); //acceleration from torque generated by the force WRT particle centroid on the clump centroid
		//if(af->force!=Vector3r(0,0,0)) cerr<<"#"<<bb->getId()<<" (##"<<bb->clumpId<<"): force="<<af->force<<", accel="<<clumpRBP->acceleration<<", aAccel="<<clumpRBP->angularAcceleration<<endl; //", force="<<af->force<<endl;
	}
	#else
		p->acceleration = af->force/p->mass;
	#endif
}


