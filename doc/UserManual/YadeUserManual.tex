\documentclass[times, 12pt]{report}

\usepackage{latex8}
\usepackage[dvips]{graphicx}
\usepackage[dvips]{color}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
%\usepackage{algorithmic}

\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}

\vspace{\stretch{2}}
\vspace{\stretch{1}}

\begin{center}
    \today
\end{center}

\vspace{\stretch{2}}
\vspace{\stretch{1}}

\begin{center}
    \hrule\smallskip\hrule\medskip\medskip
    {\Huge \bold{YADE} \\}
    {\small \bold{Y}et \bold{A}nother \bold{D}ynamic \bold{E}ngine \\}
    \medskip\medskip\medskip\medskip
    {\Large User Manual v0.5}
    \medskip\hrule\smallskip\hrule
\end{center}

\vspace{\stretch{2}}

\begin{center}
    \Large\medskip\medskip
    \begin{tabular}{rcl}
        Autor		& : & Olivier Galizzi		\\
	email		& : & olivier.galizzi@imag.fr	\\
        Laboratories	& : & L3S and GRAVIR		\\
    \end{tabular}
\end{center}

\vspace{\stretch{3}}

\begin{center}

\begin{tabular}{cccc}
%    \includegraphics[width=3cm]{logoCNRS.eps} &
%    \includegraphics[width=3cm]{logoINPG.eps} &
%    \includegraphics[width=3cm]{logoINRIA.eps} &
%    \includegraphics[width=3cm]{logoUJF.eps}
\end{tabular}

\vspace{\stretch{3}}

\medskip
\hrule \smallskip
    {\scriptsize GRAVIR / IMAG - INRIA Rhône-Alpes - ZIRST - 655 avenue de l'Europe - 38330 Montbonnot Saint-Martin - France}       \\
     {\scriptsize Téléphone : +33 4 76 61 54 26 - Télécopie : +33 4 76 61 54 40 - Adresse internet \emph{http:\bs\bs www-evasion.imag.fr} } \smallskip \\
 \smallskip \hrule

\end{center}

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction to Yade}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{What is Yade?}
YADE is a framework for performing simulations. It consists of software, libraries and plug-ins. Those help the developer to implement new algorithms linked to a simulation process (i.e. collision detection, constitutive law etc.). It is suited for 3D lagrangians simulations, like rigid-bodies simulations, discrete elements simulations, smooth particle hydrodynamic systems, mass spring systems, finite element method simulations and so on. It is not planned to add any support for 2D and eulerian simulations (like common fluid simulation) since their requirement are not compatibile with the current framework underlyings. Yade is an open source software licensed under GPL It is available for Unix/Linux system and soon for Windows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\section{Why Yade?}

	YADE provides a common framework for all users that allows them to use the same standard for developing and performing simulations. It reduces the writing of code lines and increases its compatibility between different simulation algorithms, which allows coupling them (eg. FEM with DEM). Such a framework also facilitates comparison between different algorithms (speed, stability, memory usage etc). To achieve it a common and fixed central core is needed that all the users use. Developers have to create plugins that are loaded by this central core first. The core should not be modified in future. This is the basic requirement to have a common platform. The framework is also designed to increase reusability of code: math library, computational geometry library and several others are provided into separate packages. They can be used without YADE if needed. However, their main purpose is to gather the most used algorithms, like: quaternion or matrices implementation, distances or intersections computation and many other computationnal geometry algorithms. All these kinds of algorithm are often well known by the community but they are all spread everywhere and a lot of time has to be spent to find them on the internet or papers, and then to adapt them to particular data types or code structure. Reusability is also increased through the plugins: a plugin can be build on the top of another one and can be used in different combinations of plugins to achieve the same goal without recompiling nor modifying the existing one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{How is designed Yade?}
	
	\subsection{Reusability and extensibility}
	
	The two main caracteristics of YADE to remember are reusability and extensibility. Everything was implemented in that way. The plugins are the key to those two criterions. They allow developers to add new functions without recompiling everything and so they allow to focus on  particular problems. If a user wants to add a new collision dectection algorithm there is no need to understand how dynamics works and vice versa. Of course, each plugin can be compiled independently. The developper will always deal with small pieces of code that are easy to compile and easy to maintain. Of course dependencies can be created between plugins if, for example, a user wants to reuse another plugin to create their own one. 


	\subsection{Philosophy and internal structure}

	 YADE is created to reduce almost all lagrangian discrete simulation into objects (the one we want to simulate) that are called \emph{\bold{bodies}} and \emph{\bold{interactions}} between those bodies. Most of the time interactions between bodies has to be detected and a model of the interaction is then created. Finally, responses are computed for each interactions. Those responses are called \emph{\bold{physical action}} in the framework (the physical action can be a force which will be applied in response to a contact in a force/displacement method). Applying those responses to the bodies will modify some variations of the bodies in such way that after the modification they are in a new state at the next step. All the algorithms that perform the detection of the interactions, the computation of the responses, the application of the responses and the time integration are called here \emph{\bold{engines}}.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Requirement}

	Here is described what you should know to feel at ease when developping plugins for yade.
	

\section{C++}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\


\begin{itemize}
	\item static cast and dynamic cast
	\item Standard template library (STL) (vector,list,map no float[])
	\item Boost library (shared\_ptr no float*)
	\item Singleton pattern
	\item Plugins and dynamic library
\end{itemize}

\section{Software engineering}

//				\\
//				\\
// TODO ..........		\\
//				\\
//

\begin{itemize}
	\item Object programming paradigm
	\begin{itemize}	
		\item class inheritance
		\item polymorphism 
	\end{itemize}		
	\item Singleton pattern
\end{itemize}

\section{Tips and tricks}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\begin{itemize}
	\item static\_cast<**>shared\_ptr.get() to fast access a polymorphic shared\_ptr (50 times faster than dynamic\_pointer\_cast !!)
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Get ready}

\section{Yade packaging and naming system}

Yade is splitted into several packages :
	\begin{itemize}
		\item \bold{yade-core}	: this package contains the core of YADE. All abstract classes that need to be specified as plugins to make a specific action with this core are given below. All the data structure to store the object you want to simulate ... are also defined here.
		\item \bold{yade-lib-*}: to compile yade-core you will have to compile first those libraries because they are all used by YADE. 
			\begin{itemize}
				\item \bold{yade-lib-gui-*}
				\item \bold{yade-lib-serialization-*}
			\end{itemize}
				
		\item \bold{yade-common}	: this package contains the most common implementation of abstract classes defined into yade-core. It has to be installed also because others packages base on it.
		\item \bold{yade-packages-*}	: each type of simulation of a package is defined. For example, you have yade-package-fem, yade-package-dem . Each contains implementations of abstract classes defined into yade-core related to a specific field. Most of the time they contain all plugins thet are used to perform dem or fem simulation. So if you do only DEM simulation, there is no need to install the FEM package.
	\end{itemize}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\
	
	
\section{Where from and how to download Yade}

Berlios web site : http://yade.berlios.de

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\


\section{How to install Yade}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Yade internal structure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global architecture}

	When developping a simulation framework the main issue is to find the good trade off between enough genericity and strong concepts that guide the developers and structure the simulations code while keeping them compatible. Basically, too much genericity generally leads to something too abstract where everything tends to fit into. It also leads to a slower code. This is useless. It is better to develop your own code! On the contrary, too strong concepts will limit more in terms of diversity of simulation. The solution implemented into Yade to address this issue is a double layered structure (see \figref{fig:doublelayer}):

\begin{itemize}
	\item The first layer is quite generic. It is implemented into the core of Yade mentionned in previous chapter.
	\item The second layer is built on the top of the first one and is dedicated to a specific field.
\end{itemize}

\epsfigure{19cm}{images/doublelayer.eps}{Double layered architecture of Yade.}{fig:doublelayer}

We hope that we have found with this structure a good balance between genericity and efficienty as well as between flexibility and something too embedded.

\paragraph{}	
	Each package that belongs to the specialized layer is composed by many plugins that will be plugged into the core and comes with its own specificities. For example the discrete element package defines collision detection engines for rigidbodies, the constitutive law to apply at each contact, the parameters that define a rigid body (mass, intertia, young modulus etc) and so on. This aggregation of plugins into packages has been chosen to simplify the global vision of Yade. As the number of plugins grows it becomes more and more difficult to find easily which one is dedicated to this or that task, especially if they are all stored in one place. On the top of that packaging, and in order to simplify the developement of new packages an intermediate one is available. It is called \emph{yade common} and contains some basic plugins, not specific to a particular field, and which can be reused by other packages. The \figref{fig:archigenerale} shows more precise vision of the architecture of Yade. In terms of different types of elements it can be considered as a whole for four layers. The specialized layer is build on the top of libraries that are the roots of the whole system. The core is working on the top or together with those packages. Of course a \bold{G}raphical \bold{U}ser \bold{I}nterface (GUI) is needed to let the user talk with the core and have feedback from it.

\epsfigure{19cm}{images/archigenerale.eps}{Global architecture of Yade.}{fig:archigenerale}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The first layer}

\subsection{Global structure}


	This layer contains all the abstract classes and common concepts that will be used further by plugins. It is composed of 3 main modules. The main program, the Omega singleton and the class factory singleton, as it is described by \figref{fig:mainmodules} : 
	
	\begin{itemize}
		\item The main program is just in charge of launching the GUI. The singletons are also constructed when this program starts.
		\item The factory singleton holds a database about all the available plugins and other dynamic libraries. Dynamic libraries stored on the hard drive are all scanned when yade is launched, so you do not have to take care of loading a plugin when you need it. Just ask the factory singleton to create an instance for you (you can find information about the class factory further). Anyway, when you ask for a plugin, either it is already in memory then an instance is created, otherwise the plugin is loaded from hard drive, but in any case it is transparent for the user. If you are developing plugins you do not have to care about this factory, it is ready to use.
		\item The Omega singleton holds all the data that you need to make your simulation, as the current iteration, various information about the time and time step. It also contains what is called the \emph{root body} which holds information about the simulated bodies, the current interactions between them, the simulation loop and some others information described later (explanation about rootbody can be found in next section). An independent thread is in charge of calling iteratively the simulation loop contained in this root body. Finally, a thread synchronizer is needed to synchronize the calls to the simulation loop and to other threads as the 3D display of the bodies for example. If the user wants to develop plugins he does not have to care about the threads synchronization.
	\end{itemize}
	
	
\epsfigure{19cm}{images/main_modules.eps}{Main modules.}{fig:mainmodules}


\subsection{The rootbody}

	As it is said in the introduction, the philosophy of yade is to deal with objects in interaction that need a response to be applied onto them, to go to a new state after taking the time factor into account. 
	
\paragraph{}
	Description of how and where the simulation itself is stored in the yade framework follows (like bodies, interactions, the simulation loop, the responses, etc.). Here is the concept of \emph{metabody} given. In Yade there are two kind of bodies : 
	
	\begin{itemize}
		\item "simple" bodies (we will call them bodies in the future by opposition of metabodies) which can be one discrete element, one particle, one tetrahedron. Such a body cannot do anything by itself, neither move nor interact with others bodies. It is just stored information related to its state, geometry etc.
		\item metabodies are a collection of bodies including metabodies, with the capacity of interacting and moving over the time. So the rootbody is a metabody which is at the top the the tree defined by all the bodies and metabodies that participate into the simulation. So it can be according to what you want to simulate :
		\begin{itemize}
			\item a finite element beam
			\item a rigid bodies crumbling 
			\item an piece of cloth that interact with discrete element
		\end{itemize}
		
		It is made of several bodies in interaction, that is why it is of type MetaBody. As it can be seen in \figref{fig:hierarchy}, a metaBody can be composed by bodies and/or others metabodies. The root of the tree, called the rootbody, is stored into Omega. In the given example the rootbody is composed by two metabodies. The first one is a discrete element simulation and is made of rigid spheres (which are simple bodies), and the second one is a mass spring system made of particles. In this example the rootbody will take care of the interaction between the cloth and the sphere set, whereas the two other metabodies will only take care of their own sub-bodies and the interaction between them. This is a way of having a hierarchical simulation and reusing modules to make them work together with a new one. Of course, this tree structure may not be used. If there is a rigid body simulation to run only a flat structure can be used: a rootbody with all the rigidbodies just under it.
	\end{itemize}

\epsfigure{19cm}{images/hierarchy.eps}{Hierarchy.}{fig:hierarchy}

Here is shown the full structure of a metabody to understand how it stores all the needed information and how it can "compute". As shown in \figref{fig:metabody} a metabody is composed by different types of elements :

	\begin{itemize}
		\item Data		: all data classes are passive. They are classes that contain only information (and almost no method).  For example, the properties of a rigid body (mass, inertia, geometry....). Data classes can be subdivided into three of them, as it is said previously :
			\begin{itemize}
				\item Body
				\item Interaction
				\item PhysicalAction
			\end{itemize}
		\item Containers		:  Containers are standard databases where all the data classes are stored. They provide basic database interaction, such as: insertion, deletion, research of an element. Because there are three types of data there are also three types of containers :
			\begin{itemize}
				\item A container to store the bodies called BodyContainer 
				\item A container to store the interactions called InteractionContainer
				\item A container to store the physical actions called PhysicalPhysicalAction
			\end{itemize}
		Each container has its own specific features according to the type of data it stores.
		\item Engines		: Engine classes active classes, which means that they are the classes that "compute". An engine reads and/or produce some data from, or to, containers. Usually, they contain methods and some parameters. Collision detection, damping application, recording data to hard drive, computing forces in response to collision. Those are all operations performed by engines. A particular list of engines called only once is called initializers. They are used to perform operation that has to be made only once. All the other engines compose together the simulation loop.
	\end{itemize}

\epsfigure{19cm}{images/MetaBody.eps}{Structure of a metaBody.}{fig:metabody}

\paragraph{}
	What is important to remember is the separation of methods (stored into engine classes) and information (stored into data classes) which is a recurrent pattern into Yade. It allows the user to define multiple different methods for one type of data class into different engines without either modifying, neither recompiling the data class. That implies the redundance of editing the code of the data class to make new engines. That method allows the data class to remain the same for everybody, that ensures compatibility, and using such or such engine to act on this class provides different behavior, that ensures reusability. The same data class can be used and shared widely and enable defining personnal methods that act on that class without the source code of it. This point is described in details in section about \emph{multimethods}. Basically, information is stored into one plugin, and then others plugins define the methods of that data class, then an automatic mechanism is instantly in use to call the right engine for the right type of data. This process of externalisation of methods outside of the classes is really powerfull. For example, consider a class Sphere that contains only a radius and a center. Every user can define his own method to draw the sphere, his own method to do collision detection between two spheres. As a result, the final user will be able to choose between this or that engine according to his needs (performance, accuracy etc).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data classes}

	The first type of classes we are going to explain is data classes. As already said the data classes only holds information, but almost no methods, no algorithms. This is a basic rule to respect because most of the methods will be defined outside the data classes. Let's develop again the example with the sphere (radius+center). Imaginee you write the draw method inside the sphere class. If somebody else thinks your drawing method is not good enough, too slow or simply not adapted to his own case and decide to rewrite it, both classes will no more be the same: your code may not work anymore with the new draw method; this class can no more be shared among the users. Two versions of the class sphere will exist and each time a new user needs it, he will have to choose between one of them and his code will not be compatible with either your or the other code.
	
	
\subsection{Body}

	In this section it will be described what is a "simple" body only, since the metabody class is already explained in previous section. A body contains five properties that entirely defined it :
	\begin{itemize}
		\item a GeometricalModel
		\item an InteractingGeometry
		\item a BoundingVolume
		\item a State
		\item PhyisicalParameters
	\end{itemize}
	
	In fact, there are four of them: State and PhysicalParameters are still merged but it is planned to to split them into two soon. Those properties are described in details in the following paragraphes. Each property corersponds to an abstract class store in the core and has to be specified by inheriting them to be useful.
	
	
\subsubsection{GeometricalModel}

	The \emph{GeometricalModel} of a body is simply its shape. It can be a sphere, a tetrahedron, a box, a polyhedron, a point cloud, a mesh or whatever you want, if it is a geometric shape. From the simulation point of view it is the best representation that can be in use of the corresponding real life object you want to simulate. For now, the \emph{GeometricalModel} is mainly used for display. It is also important in the way that InteractingGeometry is build on the top of it.

\paragraph{}
	Both body and metaBody can have a geometrical Model. In a case of a piece of cloth, the metabody is composed of bodies which are particles. Its geometry can be a 2D mesh defined on top of the particles, by using a particular connectivity.
	
\subsubsection{InteractingGeometry}

	This is the actual geometry through which the objects interacts with other objects. It is very useful to make a distinction between the \emph{geometricalModel} and the \emph{interactingGeometry} because one \emph{geometricalModel} may be too complex to handle interaction detection. For example, in a rigidbodies simulation objects may be arbitrary polyhedrons. This is  accurate, but may be extremely difficult to perform collision detection between such polyhedrons. The solution is to use the polyhedron as a \emph{geometricalModel} which is good enough for display and then to fill it with spheres. This union of spheres will be stored as the \emph{interactingGeometry} of your body and can be used collision detection, since it is easy to detect collision between spheres. The second interesting point is that you can build another \emph{interactingGeometry} on top of  your polyhedral geometry and compare it with the sphere union, in terms of accuracy, speed and final behavior of your simulations (see \figref{fig:geometry}). Of course, if you know how to make collision detection between two arbitrary polyhedrons you can use the polyhedral model for both  \emph{geometricalModel} and \emph{interactingGeometry}. This often appends: for example if the \emph{geometricalModel} is a sphere then they are no simpler model than the sphere to make collision detection, so the spherical model will also be used as \emph{interactingGeometry}.

\subsubsection{BoundingVolume}

	In general to speed up collision detection, or more generally interaction detection, it has to be defined a \emph{bounding volume} around the geometry of the object. A bounding volume is a very simple shape that surrounds the geometry and fits it as well as possible. This volume is then used to perform a preliminary test to check for the possibility of interaction of the two underliyng geometries. If this test fails then there is no possibility of interaction between the two objects, but if it succeeds then there may be an interaction and the \emph{interactionGeometry} will be checked. Of course, the better the bounding volume fits the geometry the more accurate this check is, but as usual it takes more time to perform.

\epsfigure{14cm}{images/geometry.eps}{Geometry.}{fig:geometry}


\paragraph{}
	One of the advantages here is the possibility to define different \emph{geometricalModel}, \emph{interactingGeometry} and \emph{boundingVolume} and test different combinations to see which one suits better your application in terms of performance or memory usage. Of course, the union of sphere can be reused with different geometrical model such as a box or an implicite surface as long as you know how to build it from such a model.
	
	
	
\subsubsection{State}

	This is the state of the body. For a rigid body it is the position and orientation as well as the velocity and the angular velocity. For a particle it is only the position and velocity. Because this is a dynamic framework informations stored here should vary along with the time according the time integration, because the objects move and accelerate.

\subsubsection{PhysicalParameters}

	This property corresponds to the remaining information about a body that is not related to any geometrical informations or information about the state of the body. For a rigid body it can contain the mass, the inertia matrix, the young modulus and the poisson's ratio. For a finite element it can contain the stiffness matrix and the mass. Usually the information stored here is not variable.

\subsubsection{Conclusion on body}

To sum up, Yade core contains six abstract classes that fully define what is a body :
\begin{itemize}
	\item \emph{Body}
	\item \emph{GeometricalModel}
	\item \emph{InteractingGeometry}
	\item \emph{BoundingVolume}
	\item \emph{State}
	\item \emph{PhysicalParameters}
\end{itemize}

You should not use the class Body to define you own body but there are no other choices. By choosing one combination of the five remaining classes you create one type of body. The \figref{fig:bodyexample} shows an example that define a rigid body with a polyhedral geometry, a union of sphere as interacting geometry and an axis aligned bounding box as bounding volume.

\epsfigure{19cm}{images/bodyexample.eps}{Example of body. Here is defined a rigid body.}{fig:bodyexample}



There are a lot of possible dispatchers according to the number of different data used. Because a dispatcher is identified by the dispatched type and the returned type.
Currently we use 8 type of data :
	\begin{itemize}
		\item BoundingVolume
		\item InteractingGeometry
		\item GeometricalModel
		\item State
		\item PhysicalParameters
		\item NarrowInteractionGeometry
		\item InteractionPhysics
		\item PhysicalAction
	\end{itemize}
	
	
\subsection{Interactions}

	There are mainly two types of interactions :
	\begin{itemize}
		\item interactions that appear due to spatial proximity and that disappear by themselves when spatial proximity no longer exists. This kind of interaction is called \emph{volatileInteraction} in the Yade framework. For example, a collsion between two rigid bodies is one type of \emph{volatileInteraction}.
		\item By opposition of \emph{volatileInteraction} there is a \emph{persistentInteraction} that is defined manually in the configuration file most of the time but they also can occur during runtime. They are not disappearing by themselves like \emph{volatileInteraction} but they have to be defined by an arbitrary criterion. That will cause the destruction or modification of \emph{persistentInteraction}. For example, you may want to create some cohesive links between rigid bodies, that will be created when the configuration file is loaded. Those links will be destroyed when an arbitrary strengh criterion is reached. You may also want to glue two bodies when they collide: this "glue" will not disappear when the collision no longer exists but when a specific criterion is overcome, as for example a distance threshold. In both cases, the type of the interaction is persistent interaction because the interaction does not disappear spontaneously but according to a criterion that the user has defined.
	\end{itemize}
	
	\paragraph{}
	The only difference between them is that they are stored in two different containers to be in a quick access. Both of them are composed of the two following properties: 
	\begin{itemize}
		\item an interaction geometry
		\item an interaction physics
	\end{itemize}
	
They are described in details in next sections. 
	
\subsubsection{InteractionGeometry}

	This is a snapshot of the geometry of the contact at current time step. This property is build by taking into account the \emph{interactingGeometry} of two (if you are dealing with binary interaction such as contact) or more bodies. It should contain enough information so that after its detection and modelisation, there is no need to access again the interacting geometry of the corresponding bodies to make any further computation or to access more information. The \figref{fig:interactionGeometry} shows two examples of interaction geometry.
	
	\epsfigure{19cm}{images/interactionGeometry.eps}{Two examples of interaction geometry.}{fig:interactionGeometry}

\paragraph{}
	 Of course once a new type of \emph{interactionGeometry}is defined, the corresponding engine(s) which will construct this property if an interaction is found between two bodies, have to be defined. The fewer information you need to build the \emph{interactionGeometry} the more reusable will be this class and also the engines that come with it. It is quite important because usually the engines in charge of detecting and modelising interactions such as contact can be quite complex. So it is much better when they can be reused by many simulations . 
	

\paragraph{Caution :} Be careful to not confuse between the \emph{interactingGeometry} of a body which is the actual geometry through which the body interacts and the \emph{interactionGeometry} which is the geometry of an interaction.


\subsubsection{InteractionPhysics}

	This contains all the physical parameters of the interaction which are rather not related to some geometric information. For example, you may need to compute the normal and shearing stiffness at a contact between two objects from their young modulus and poisson's ratio. These stiffnesses will be used as long as the contact remains and they should be stored into a specific interactionPhysics class, maybe aside with other properties.
	
\paragraph{}
	
	 This property can be much more specific than the \emph{interactionGeometry} because it is usually easier to build. Let's take an example. In some discrete element simulation, the previous normal at the contact point is required to compute the shearing force. This previous normal has to be stored into the \emph{InteractionPhysics} property even if it seems to be related to some geometrical information and so stored into the \emph{interactionGeometry} property. The point is that this normal is really specific to a particular method so if it is stored into the \emph{interactionGeometry} of the contact then in every simulation method that do not need it, this attribute will be defined and not used: so both memory and CPU usage will be wasted to store and compute it.

\subsubsection{Conclusion on interaction}

	An interaction is made of two properties : 
	\begin{itemize}
		\item an interaction geometry
		\item an interaction physics
	\end{itemize}

	This means in the core of Yade you will find three abstract classes :
	\begin{itemize}
		\item \emph{Interaction}
		\item \emph{InteractionGeometry}
		\item \emph{InteractionPhysics}
	\end{itemize}
	
	To define your own Interaction you have to overload both \emph{InteractionGeometry} and \emph{InteractionPhysics}. Of course it would have been possible to use here only one property which is the merge between the geometry and the physicals parameters of the interaction. But to increase reusability of code it has been choosen to split them. Of course, it is up to the user to think of what should be inside the geometry and inside the physical parameters.

\subsection{PhysicalAction}

	A physical action is everything that can be applied to a body to modify its state usually in response to some interaction. For a rigidbody, it can be :
	\begin{itemize}
		\item a force $[{{kg m}\over{s^2}}]$
		\item an acceleration $[m/s^2]$
		\item an impulse $[kg m/s]$
		\item a displacement $[\Delta m]$
		\item a velocity $[m/s]$
		\item a momentum $[kg m^2/s^2]$
		\item or a combination of them.
	\end{itemize}
	
//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{Conclusion on data classes}

Currently 8 types of abstract data classes are defined into Yade :

	\begin{itemize}
		\item BoundingVolume
		\item InteractingGeometry
		\item GeometricalModel
		\item State
		\item PhysicalParameters
		\item NarrowInteractionGeometry
		\item InteractionPhysics
		\item PhysicalAction
	\end{itemize}	

By inheriting them you can define your own bodies, interactions and physical action.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\section{Containers}

	For each type of data we need a way to store it. That's why three types of containers are defined : 
	\begin{itemize}
		\item a container that stores the bodies
		\item a container that stores the interactions
		\item a container that stores the physical actions
	\end{itemize}
	
	\paragraph{}
	We have choosen to encapsulate the containers in which the data classes are stored so that it is possible to define different container types. One will be made with chain list and will have fast insertion, an other will be made with vector and will have a fast access to it, etc. The big advantage, is that depending of your application, you will be able to privilege such or such property of your containers. For example, if you know that you are not going to add or remove bodies on runtime, there is no need to use a container that is able to preserve the ids of the bodies (which are used to identify them into the interaction for example). If you know that you are dealing only with binary interactions, then you may implement an optimized container that is able to store only binary interactions.
	The counterpart is that by adding one level of abstraction we may loose some performances in terms of speed of access or insertion, but we think this is negligible compared to the benefits.

	\paragraph{}
	Of course, it is up to you to choose the one which is the best suited for your particular application. You may want fast insertion or fast access and this affects the type of the container used. Most of the containers will be stored into yade common package because these are highly reusable.

\subsection{BodyContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{InteractionContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{PhysicalActionContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%just find no insert 
%usefull to store responses to collision if we need access to them for example to have access to sum of forces on one body.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Engines}

	Engines read and/or produce  some data from/to containers. Some engines are modifying or reading data, some others are creating data, some others can delete data.
	For now engines only perform those basic operations but we plan to make engines that are able to do complex operations such as splitting bodies, merging bodies, transforming a body into another. The engines are stored into two places :
	\begin{itemize}
		\item in the simulation loop
		\item in the initializer list
	\end{itemize}
	
Those placed in the initializers list are called once when a new configuration file is loaded. For example they can compute the bounding volume of the bodies from their interacting geometry. Those placed into the simulation loop are called one after each other in loop, until the simulation ends. Here can be found engines that detect collision, compute responses to collision, save results, etc.

\paragraph{}
	Here are some common concrete examples. A engine can :
	\begin{itemize}
		\item access data from \emph{BodyContainer} and use the \emph{BoundingVolume} property of the bodies to find all potential pair of interacting bodies
		\item read data from \emph{BodyContainer} and \emph{InteractionContainer} and use the \emph{InteractingGeometry} property as well as all the potential collision to modelise the \emph{InteractionGeometry} of collision that really occur.
		\item produce \emph{GeometricalModel} for bodies. For example create a Polyhedron from WRML file.
		\item access all the forces stored into \emph{PhysicalActionContainer} and update data to BodyContainer by applying those forces to rigid bodies.
		\item update all forces stored into \emph{PhysicalActionContainer} by applying some damping
		\item access the collisions stored in the \emph{volatileInteractionContainer}, then compute forces in response to those collisions and finally store those forces into \emph{PhysicalActionContainer}
		\item read data from one of the containers to write them down on the hard drive
	\end{itemize}

All engines classes are serializable, because an engine often uses parameters that you may want to tune yourself in the configuration file. Different type of engines can be found in Yade :
	\begin{itemize}
		\item stand alone engines
		\item Meta engine which are engines composed of engine 
		\item engine unit which is a part of an meta engines
		\item DeusExMachina engines 
	\end{itemize}

	
\subsection{Stand alone engines}

	A stand alone engine inherits only from the Engine class. It performs a unique operation : for example, it computes the appropriate time step, it computes the forces to apply the bodies in response to a collision.
	
	
	\code
	{
		\> \>	\class Engine : \kw{public} Serializable				\\
		\> \>	\{									\\
		\> \> \>	\pub : Engine() \{\};						\\
		\> \> \>	\pub : \virtual ~Engine() \{\};					\\
												\\
		\> \> \>	\pub : \virtual \bool isActivated() \{ \return \true; \};	\\
		\> \> \>	\pub : \virtual \void action(Body*) \{ throw; \};		\\
		\> \> \>	\pro : \virtual \void postProcessAttributes(\bool d) \{\};	\\
		\> \> \>	\pub : \virtual \void registerAttributes() \{\};		\\
												\\
		\> \> \>	REGISTER\_CLASS\_NAME(Engine);					\\
		\> \>	\};									\\
		\> \>	REGISTER\_SERIALIZABLE(Engine,\false);					
	}			
		
	Putting aside the usual line linked to serialization of class factory, the two important remaining methods are :


	\code
	{
		\> \virtual \bool isActivated();	\\
		\> \virtual \void action(Body*);
	}
	
	In the simulation loop the calls to engines are made in two steps. First a call is made to \emph{isActivated} to know if the engine is active or not. By default this function returns \emph{true} so if it is not overloaded (which is the case most of the time, the engine is always considered as active. You can define in this method your own criterion of activity. For example, if you want to check for new contact each 10 iterations you just have to write :
	
	\code
	{
		\>	\bool myEngine::isActivated()						\\
		\>	\{									\\
		\> \>		\return (Omega::instance().getCurrentIteration()\%10==0);	\\
		\>	\}
	}	
	
	Only if an engine is active the method action is called. The parameter \emph{Body} is usually a MetaBody that contains all the information you may need to make any task: collision detection, responses computation. 
	
\subsection{MetaEngine and EngineUnit}

	A meta engine is an engine made of engines. It usually inherits from both the Engine class and the DynlibDispatcher class from multimethod library. This kind of engine is used to perform specialized operation on particular type of data. As previously said, they usually use a lot the multimethod library which allows dispatching.
They are very useful to handle the method of the data classes as we will see. For now there are mainly two types of  meta engines. One-dimensional meta engine and two-dimensional meta engine. Both of them are composed by EngineUnit that inherits from FunctorWrapper class. Basically, according to the type of data they work with, a meta engine will call the correct Engine unit. So first, when a metaengine is defined, the abstract class for all the engine unit has also to be defined. One metaengine works with one type of engine unit.

\paragraph{}
	One dimensional meta engines are mainly used to externalize virtual method of one of the data classes. You just have to specify which type of engine unit to use on which type of data, then, when the metaengine is looping over the data classes it is dealing with, the correct engine units are automatically called. For example you can externalize the draw method out of the geometricalModel. Then you define a 1d metaengine that works with one engine unit that takes one \emph{geometricalModel} as parameter and define how to draw it. If you are dealing with tetrahedrons and cubes you have to make 2 engine units. One will know how to draw a tetrahedron, the other how to draw a cube. The metaengine will then call the correct engine unit when you will ask to draw a sphere or a cube. This is illustrated by \figref{fig:1dmetaengine}.

\epsfigure{19cm}{images/1DMetaEngine.eps}{1DMetaEngine.}{fig:1dmetaengine}

\paragraph{}
	Two dimensional meta engines are the same as one dimensional but they dispatch on two types of data. This is the most interresting type of meta engine. The \figref{fig:2dmetaengine} shows an meta engine that knows which engine unit to call when you ask for collision detection between a sphere and a cube or 2 spheres.

\epsfigure{11cm}{images/2DMetaEngine.eps}{2DMetaEngine.}{fig:2dmetaengine}


\subsection{DeusExMachina}
	
	It is a stand alone engine which contains a list of subscribed bodies. For each subscribed body it applies a particular movement or condition according to an arbitrary law defined by the user. It can be used to apply border condition to apply gravity to all bodies and so on.
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\chapter{The libraries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Serialization}

	Serialization is the process of taking an object and converting it to a format in which it can be transported across a network or persisted to a storage location (ie hard drive disk). The storage location could be as simple as using a file or a database. The serialized format contains the object's state information. Deserialization is the process of using the serialized state information to reconstruct the object from the serialized state to its original state. In essence, the process of serialization allows an object to be serialized, shipped across the network for remoting or persisted in a storage location such as an XML file, and then be reconstructed for use at a later point in time. 
	Through the library yade-lib-serialization, Yade proposes an easy way for serializing objects to a C++ stream.  This stream can be a file on the disk, a chunk of memory or a network stream. For now the format used to save and restore the state of  a class is XML. But it is possible to define new format, as binary, YAML and so on without modifying or recompiling the  yade-lib-serialization library. This is a very powerfull capacity, since you can define your own format with minimal work to do according to what your needs: a compact format, a more descriptive one.

	On the top of that we provide a very easy way to make an object serializable. Let's consider the class A defined as follow :
	
		\code
		{
			\> \> \class  A					\\
			\> \> \{					\\
			\> \> \> \pri : \integer i;			\\
			\> \> \> \pro : \float f1, f2, average;		\\
			\> \> \> \pub : \kw{Vector3} v;			\\
			\> \> \}					
		}
		
	To make it serializable you just have to add the following lines : 

		\code
		{
				\> (1)	\>	\inc <yade-lib-serialization/Serializable.hpp>			\\
														\\
				\> (2)	\>	\class A : \kw{public} Serializable				\\
				\>	\>	\{								\\
				\>	\>\>		\pri : \integer i; 					\\
				\>	\>\>		\pro : \float f1, f2, average;				\\
				\>	\>\>		\pub : \kw{Vector3} v;					\\
														\\
				\> (3)	\>\>		\pub : \void registerAttributes();			\\
				\> (4)	\>\>		\pro : \virtual \void postProcessAttributes(\bool d);	\\
				\> (5)	\>\>		\pro : \virtual \void preProcessAttributes(\bool d);	\\
														\\      
				\> (6)	\>\>		REGISTER\_CLASS\_NAME(A);				\\			       
					\>\>	\}								\\
														\\
				\> (7)	\>\>       REGISTER\_SERIALIZABLE(A,\false); 								       
		}

	Line (1) is needed to include the class Serializable which is the basic interface to all serializable classes. That's why on line (2) you have to make your class inheriting the Serializable one.
	On line (3) is defined the registerAttributes function which you have to overload. With this example you will have : 
	
	\code
	{
	   \> \>	\void A::registerAttributes()	   \\
	   \> \>	\{				   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(i);	   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(f1);   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(f2);   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(v);	   \\
	   \> \>	\}
	}
	
	For explanation about REGISTER\_CLASS\_NAME (line 6) macro see section about class factory.

	By calling the macro REGISTER\_ATTRIBUTE (line 7) you tell the serialization system that you want to serialize such or such attribute.

	Of course if you have a class hierarchy as this one :
	
	\code
	{
		\> \>	\class B : \kw{public} A			\\
		\> \>	\{						\\
		\> \> \>	\pri : \kw{Matrix3} m;			\\
									\\
		\> \> \>	\pub : \void registerAttributes();	\\
		\> \>	\}						\\
									\\
		\> \>	REGISTER\_SERIALIZABLE(B,\false);		\\
	}

	You need to call from the registerAttributes function of B the registerAttributes function of A. If you do not, attributes that comes from A won't be serialized when B is serialized. So it is better to call always the registerAttributes of the mother class so that you are sure that a new attributes are defined in future into this mother class, and they will be taken into account in your own class.

	\code
	{
		\> \>	\void B::registerAttributes()		\\
		\> \>	\{					\\
		\> \> \>	A::registerAttributes();	\\
		\> \> \>	REGISTER\_ATTRIBUTE(m);		\\
		\> \>	\}					
	}
	
	On line (4) and (5) you can overload if you want (but it is not necessary) the postProcessAttributes and preProcessAttributes functions. The preProcessAttributes function is called before the serialization and deserialization of the class. The same is needed for function postProcessAttributes which is called after serialization and deserialisation. Inside the function you know if you are in a serializing or deserializing process by checking the boolean value d. If it is true then you are currently deserializing the object, if it is false then you are serializing the object. It may be very usefull for example if you do not need to serialize one attribute because you can compute it from one or more others attributes. In class A you may not want to serialize attribute average because it is just the average between f1 and f2. So to restore A in a correct state after deserialisation you can overload postProcessAttributes as follow : 

	\code
	{
		\> \> 	\void A::postProcessAttributes(\bool d)			\\
		\> \> 	\{							\\
		\> \> \>	if (d) \comment{if we are deserializing A}	\\
		\> \> \> \>		average = (f1+f2)/2;			\\
		\> \>	\}						
	}

	Of course if you are into B it is better to do as follows for the same reason mentionned with the function registerAttributes.
	\code
	{
		\> \> 	\void B::postProcessAttributes(bool d)		\\
		\> \> 	\{						\\
		\> \> \>	A::postProcessAttributes(d);		\\
		\> \>	\}						\\
	}

	Finally you have to register your class to the serialization system by calling the macro REGISTER\_SERIALIZABLE after the definition of your class. This macro takes two parameters. The first one is the name of your class. The second one is not improtant for now and should be false.


	The serializable library can't work alone. You have to define what we have called an IOFormatManager that will be in charge of defining all the specificities to a particular format. That's why it is possible to define your own format, by defining your own IOFormatManager. As said before, for now the only IOFormatManager defined is the XMLFormatManager that serializes object to the XML format. Let's see how to use an IOForamtManager together with the serialization library. First of all you have to put your IOFormatManager into a library. XMLFormatManager is stored into the yade-lib-serialization-xml library.

To deserialize the serializable object A from a stream :

	\code
	{
		\> \> 	A a;											\\
		\> \> 	a.i	\> = 2;				\comment{I know it is private :)}		\\
		\> \> 	a.f1	\> = 3.14.15;									\\
		\> \> 	a.f2	\> = 6.2;									\\
		\> \> 	a.v	\> = Vector3(1,2,3);		\comment{I know it is protected :)}		\\
		\> \> 	\sharedptr{XMLManager} xmlManager(\new XMLManager);					\\
		\> \> 	ofstream fileStream("fileA.xml");							\\
		\> \> 	xmlManager->saveArchive(fileStream,a,"A");						\\
		\> \> 	fileStream.close();									
	}
	
	The result of those lines is a file whose name is fileA.xml and which contain the following : 

	\code
	{
		\> \>	<A i="2" f1="3.1415" f2="6.2" v="{1 2 3}" \bs A>
	}

To deserialize the serializable object A from a stream :
		
	\code
	{
		\> \> \sharedptr{XMLManager} xmlManager(new XMLManager);			\\
		\> \> ifstream fileStream("fileA.xml"); \comment{here we choose a file stream}	\\
		\> \> xmlManager->loadArchive(fileStream,A,"A");				\\
		\> \> fileStream.close();							
	}
	
	And this load to the content of file fileA.xml into object A.


	For (de-)serialization to and from files facilities are provided. To serialize an serializable object "s" to a file named "fileName.xml" using the "XMLManager" class  as IOManager, you just have to write : 

	\code
	{
		\> \> IOFormatManager::saveToFile("XMLFormatManager", "fileName.xml","S",s);
	}

To restore the state of object "s" from the same file you just have to write : 

	\code
	{
		\> \> IOFormatManager::loadFromFile("XMLFormatManager","fileName.xml","S",s);
	}


	Of course you can do much complex operations if your object holds pointer on others serializable object, or if it contains vector of vector of int. Any combinations work as long as you use STL standard types. For example :

	\code
	{
		\> \> 	\class Body : \kw{public} Serializable					\\
		\> \>	\{									\\
		\> \> \>	\pub : \sharedptr{PhysicalParameters} physicalParameters;	\\
		\> \> \>	\pub : \sharedptr{GeometricalModel} geometricalModel;		\\
		\> \> \>	\pub : \sharedptr{InteractingGeometry} interactingGeometry;	\\
		\> \> \>	\pub : \sharedptr{BoundingVolume} boundingVolume;		\\
		\> \> \>	\pub : \integer id;						\\
		\> \> \>	\pub : \bool isDynamic;						\\
		\> \>	\}
	}

	\code
	{
		\> \> 	\class Polyhedron : \kw{public} GeometricalModel			\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{vector}<\kw{Vector3}> vertices;			\\
		\> \> \>	\pub : \kw{vector}<\kw{vector}<\kw{Vector3}> faces;		\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \> 	\}
	}


	\code
	{
		\> \> 	\class Sphere : \kw{public} InteractingGeometry				\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} center;					\\
		\> \> \>	\pub : \float radius;						\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \>	\}
	}
	
	\code
	{
		\> \> 	\class AABB : \kw{public} BoundingVolume				\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} center;					\\
		\> \> \>	\pub : \kw{Vector3} extents;					\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \>	\}
	}
	
	\code
	{
		\> \> 	\class RigidBodyParameters : \kw{public} PhysicalParameters		\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} inertia;					\\
		\> \> \>	\pub : \float mass;						\\
		\> \> \>	\pub : \kw{Vector3} velocity;					\\
		\> \> \>	\pub : \kw{Vector3} angularVelocity;				\\
		\> \> \>	\pub : \kw{Se3} se3;						\\
		\> \>	\}
	}

	Let's now define a body and serialize it into a file:
	
	\code
	{
		\> \> 	Body b;													\\
		\> \> 	b.physicalParameters	\> \> \> \> \> = \sharedptr{PhysicalParameters}(\new RigidBodyParameters);	\\
		\> \> 	b.geometricalModel 	\> \> \> \> \> = \sharedptr{GeometricalModel}(\new Polyhedron);			\\
		\> \> 	b.interactingGeometry	\> \> \> \> \> = \sharedptr{InteractingGeometry}(\new Sphere);			\\
		\> \> 	b.boundingVolume 	\> \> \> \> \> = \sharedptr{BoundingVolume}(\new AABB);				\\
		\> \> 	\comment{}												\\	
		\> \> 	\comment{... of course we need to specify all the values here}						\\
		\> \> 	\comment{}												\\
																\\	
		\> \> 	IOManager::saveToFile("XMLMAnager", "myBody.xml","b",b);
	}

	The result is a file named "myBody.xml" that contains the following :
	
	\code
	{
		\> \> 	<b id="3" isDynamic="1">									\\
		\> \> \>	<physicalParameters \_className\_="RigidBodyParameters" inertia="{2.3 4.9 4.1}" 	\\
		\> \> \> \>		mass="3.23" 									\\
		\> \> \> \>		velocity="{2.4 0 0}" 								\\
		\> \> \> \>		angularVelocity="{0 0 0}" 							\\
		\> \> \> \>		se3="{1 3 2 1 0 0 0}" 								\\
		\> \> \>	\bs physicalParameters>								\\
		\> \> \>	<geometricalModel \_className\_="Polyhedron" color="{1 0 0}" ...			\\
		\> \> \>	<interactingGeometry \_className\_="Sphere" color="{1 0 0}" ...				\\
		\> \> \>	<boundingVolume \_className\_="AABB" color="{1 0 0}" ...				\\
		\> \> 	<\bs b>
	}

	With this library, it is even possible to serialize STL container, basic type such as int, float and types defined into yade-lib-wm3-math, which means you can do something like that : 

	\code
	{
		\> \> 	\float f = 10;							\\
		\> \> 	\kw{vector}<\kw{Vector3}> v;					\\
		\> \> 	v.\kw{push\_back}(Vector3(10, 20, 30));				\\
		\> \> 	v.\kw{push\_back}(Vector3(2.3, 1.7, 4.7));			\\
		\> \> 	v.\kw{push\_back}(Vector3(0, 0, 0));				\\
		\> \> 	IOManager::saveToFile("XMLMAnager", "filef.xml","f",f);		\\
		\> \> 	IOManager::saveToFile("XMLMAnager", "filev.xml","v",v);
	}

and get this result inside filef.xml :

	\code
	{
		\> \> <f>10<\bs f>	
	}

and in file filev.xml :

	\code
	{
		\> \> <v>[ {10 20 30} {2.3 1.7 4.7} {0 0 0} ]<\bs v>	
	}

	The nice last feature of this library is the possibility to (de-)serialize to graphical widget. For now only QT library is supported, only few basic types are supported but it is planned to improve a lot this feature, since it is providing automatic generation of graphical user interface. This is what is used to generate the center part of the file generator used into yade to generate initial configuration.


\epsfigure{8cm}{images/serialization2QT.eps}{serialization2QT.}{fig:serialization2qt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Class factory}

	The class factory provides an easy way of creating new instances of classes. All classes that register themselves into class factory can be asked for instatination. From a user point of view it is very easy to create a new intance by just calling one of the three functions stored into the class factory singleton : 

	\begin{itemize}
		\item \sharedptr{Factorable} createShared(\str name) : this function creates a shared pointer that points on a factorable class of the given name
		\item Factorable* createPure(\str name ) :  this one creates a C pointer that points on a factorable class of the given name
		\item void * createPureCustom(\str name ) : same for this one but it is returning a void C pointer.
	\end{itemize}
	
Of course this is mainly used to create instances of classes stored into dynamic library. In this example you ask for a specific instance and the class factory will create it if the class is already in memory, or it will look on the hard drive if a dynamic library has the same name as the requested class instance, then will load the dynamic library and finally will return an instance of this class. This process is totally transparent for the user, so you don't have to care about loading plugin in your code, just ask the factory as follow : 

	\code
	{
		\> \> \sharedptr{Factorable} f\_shared = ClassFactory::instance().createShared("A");
	}
or
	\code
	{
		\> \> Factorable* f\_pure = ClassFactory::instance().createPure("A");
	}
or
	\code
	{
		\> \> void * voidstar = ClassFactory::instance().createCustom("A");
	}

Those lines will create an instance of the class A and return a specific pointer onto it depending of the choosen function. You can then use a static or dynamic cast onto type A to retrieve your specific type : 

	\code
	{
		\> \> sharedptr{A} a\_shared = dynamic\_pointer\_cast<A>(f\_shared);
	}
or 
	\code
	{
		\> \> A * a\_pure = dynamic\_cast<A*>(f\_pure);
	}
or 
	\code
	{
		\> \> A * a\_custom = dynamic\_cast<A*>(voidstar);
	}
	

	To define a factorable class A, you just have to inherit it from class Factorable and then call the macro REGISTER\_CLASS\_NAME with as argument the name of the class. Finally you have to call the REGISTER\_FACTORABLE macro after the definition of your class to register it into the class factory singleton.

	

	\code
	{
		\> \> 	\#include <yade-lib-factory/Factorable.hpp>	\\
									\\
		\> \> 	\class A : \kw{public} Factorable		\\
		\> \>	\{						\\
		\> \> \>	REGISTER\_CLASS\_NAME(A);		\\
		\> \> 	\}						\\
									\\
		\> \>	REGISTER\_FACTORABLE(A);
	}

	All serializable classes also are Factorable that's why you have to call this macro in all classes that inherit Serializable. The REGISTER\_SERIALIZABLE\_CLASS macro calls automatically the REGISTER\_FACTORABLE one that's why you do not have to do it by hand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Multimethods}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

Here are some ideas :
\begin{itemize}
	\item multi-virtual external method for objects.
	\item objects are becoming POD (in fact not because they inherit from serializable ... but from user point of view it is true) and all method are outside so it is possible to define as many as we want without modifying existing code
	\item All dispatcher (metaengine) are named after what they are modifying/creating/updating ...
	\item optimized dispatching (no if elseif elseif ...)
	\item inside functor possibility to use static\_cast because the dispatching is correct so you know that in the parameter of the functor you have the expected type in the polymorphic pointer.  So no need to use dynamic\_cast followed by a test to know if it was successfull.
\end{itemize}

Dispatching : 2 conditions
	\begin{itemize}
		\item the entity on which we are dispatching has to be multiple (multiple BV,  multiple pair of InteractingGeometry ...)
		\item each functor called by dispatcher have to be independent
			\begin{itemize}
				\item narrow collision between sphere1 and box2 is independent from narrow collision between sphere1 and sphere2
				\item in force displacement method computing a force that is a result of interaction1 is independent from computing a force that is a result of interaction3
				\item in pruning broad collider (SAPCollider) the sort make all the BV not independent so it is not possible to dispatch
using SWIFT and its global scene object make all the objects not independent either.
			\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{The second layer : the packages and plugins}

	In this layer specific to a field, we are going to define our own bodies, interactions, physicals actions, containers, and engines. Basicaly everything described in previous section can be redifined: new geometricalModel, new interactingGeometry, new boundingVolume, new interactionGeometry, new engines. Even new containers that are specific to your own problem can be rewrited: for exemple if you need fast insertion, fast acccess or fast deletion, you can write a specific container as long as you implement the standard interface.

You have to specify all the customizable element described in previous section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creating plugins}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of body}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of Interaction}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{How to create your own type of PhysicalAction}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of Engine}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to generate a configuration file}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to generate a custom simulation loop}

% using graphical tool

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Creating your own GUI}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Creating your own serialization format}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\addcontentsline{toc}{chapter}{Bibliographie}
%\nocite{*}
%\bibliographystyle{alpha}
%\bibliography{bibliographie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
